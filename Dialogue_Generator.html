<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Dialogue Generator</title>
    <script>
        // Security Utility Functions
        const securityUtils = {
            // Safely validate and sanitize URLs to prevent XSS
            // Returns sanitized URL or default placeholder if URL is invalid
            sanitizeUrl: function(url, defaultUrl) {
                // If no URL or empty string, return default
                if (!url || typeof url !== 'string') {
                    return defaultUrl || '';
                }
                
                try {
                    // Parse URL to validate it
                    const parsedUrl = new URL(url, window.location.origin);
                    
                    // Only allow safe protocols and data URLs for images
                    if (parsedUrl.protocol === 'http:' || 
                        parsedUrl.protocol === 'https:' || 
                        (url.startsWith('data:image/') && !url.includes('script'))) {
                        
                        // Further sanitize the URL by removing any potentially dangerous characters
                        const sanitized = url.replace(/['"<>]/g, '');
                        
                        // If sanitization removed characters (potential attack attempt),
                        // log and return default URL
                        if (sanitized !== url) {
                            console.warn('Potentially dangerous URL was sanitized:', url);
                            return defaultUrl || '';
                        }
                        
                        return sanitized;
                    }
                } catch (e) {
                    // URL parsing failed, return default
                    console.warn('Invalid URL:', url);
                }
                
                return defaultUrl || '';
            },
            
            // Generic text sanitizer for display in HTML contexts
            sanitizeText: function(text) {
                if (!text || typeof text !== 'string') {
                    return '';
                }
                
                // Convert special characters to HTML entities
                return text.replace(/[&<>"']/g, function(m) {
                    return {
                        '&': '&amp;',
                        '<': '&lt;',
                        '>': '&gt;',
                        '"': '&quot;',
                        "'": '&#39;'
                    }[m];
                });
            }
        };
    </script>
    <style>
        :root {
            --discord-bg: #36393f;
            --discord-input-bg: #40444b;
            --discord-text: #dcddde;
            --discord-sidebar: #2f3136;
            --discord-accent: #5865f2;
            --discord-hover: #32353b;
            --discord-header: #202225;
            --discord-green: #57f287;
            --discord-red: #ed4245;
            --discord-yellow: #fee75c;
            --discord-secondary: #4f545c;
            --discord-light: #b9bbbe;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Whitney', 'Helvetica Neue', Helvetica, Arial, sans-serif;
        }
        
        body {
            background-color: var(--discord-bg);
            color: var(--discord-text);
            display: flex;
            height: 100vh;
        }
        
        .sidebar {
            width: 320px;
            background-color: var(--discord-sidebar);
            height: 100%;
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid var(--discord-secondary);
            box-shadow: 0 0 8px rgba(0, 0, 0, 0.3);
        }
        
        .setup-panel {
            background: linear-gradient(135deg, var(--discord-input-bg) 0%, #3a3d44 100%);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid var(--discord-secondary);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        
        .setup-panel:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.25);
        }
        
        .setup-panel h2 {
            margin-bottom: 16px;
            color: white;
            font-size: 18px;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            user-select: none;
            position: relative;
            padding-right: 40px;
        }
        
        .setup-panel h2::before {
            content: '';
            width: 4px;
            height: 20px;
            background: linear-gradient(135deg, var(--discord-accent), #4752c4);
            border-radius: 2px;
        }
        
        .setup-panel h2::after {
            content: '▼';
            position: absolute;
            right: 20px;
            font-size: 12px;
            transition: transform 0.3s ease;
            color: var(--discord-accent);
            opacity: 0.8;
        }
        
        .setup-panel.collapsed h2::after {
            transform: rotate(-90deg);
        }
        
        .setup-panel-content {
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.3s ease;
            max-height: 2000px;
            opacity: 1;
        }
        
        .setup-panel.collapsed .setup-panel-content {
            max-height: 0;
            opacity: 0;
            margin-bottom: 0;
        }
        
        label {
            display: block;
            margin: 12px 0 6px;
            font-size: 14px;
            font-weight: 600;
            color: var(--discord-light);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        input, textarea, select {
            width: 100%;
            padding: 12px 16px;
            background: linear-gradient(135deg, var(--discord-header) 0%, #1a1c1f 100%);
            border: 2px solid transparent;
            border-radius: 8px;
            color: var(--discord-text);
            margin-bottom: 12px;
            font-size: 14px;
            transition: all 0.3s ease;
            outline: none;
        }
        
        input:focus, textarea:focus, select:focus {
            border-color: var(--discord-accent);
            background: var(--discord-header);
            box-shadow: 0 0 0 4px rgba(88, 101, 242, 0.1);
            transform: translateY(-1px);
        }
        
        input:hover, textarea:hover, select:hover {
            border-color: var(--discord-secondary);
            background: var(--discord-header);
        }
        
        textarea {
            resize: vertical;
            min-height: 80px;
        }
        
        .char-setup {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #4f545c;
        }
        
        .char-setup h2 {
            font-size: 16px;
            color: white;
            font-weight: 600;
            margin-bottom: 12px;
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding-right: 30px;
            position: relative;
        }
        
        .char-setup h2::after {
            content: '▼';
            font-size: 12px;
            transition: transform 0.3s ease;
            color: var(--discord-accent);
            opacity: 0.8;
            position: absolute;
            right: 10px;
        }
        
        .char-setup.collapsed h2::after {
            transform: rotate(-90deg);
        }
        
        .char-setup-content {
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.3s ease;
            max-height: 1000px;
            opacity: 1;
        }
        
        .char-setup.collapsed .char-setup-content {
            max-height: 0;
            opacity: 0;
            margin-bottom: 0;
        }
        
        .avatar-preview {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: var(--discord-header);
            margin-right: 10px;
            overflow: hidden;
            display: inline-block;
        }
        
        .avatar-preview img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .char-row {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
        }
        
        button {
            background: linear-gradient(135deg, var(--discord-accent) 0%, #4752c4 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            margin-top: 8px;
            width: 100%;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(88, 101, 242, 0.3);
            position: relative;
            overflow: hidden;
        }
        
        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0));
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        button:hover {
            background: linear-gradient(135deg, #4752c4 0%, #3c4bc7 100%);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(88, 101, 242, 0.4);
        }
        
        button:hover::before {
            opacity: 1;
        }
        
        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(88, 101, 242, 0.3);
        }
        
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        
        .chat-header {
            height: 60px;
            background: linear-gradient(135deg, var(--discord-header) 0%, #1a1c1f 100%);
            border-bottom: 2px solid var(--discord-secondary);
            display: flex;
            align-items: center;
            padding: 0 24px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }
        
        .chat-header h2 {
            color: white;
            font-weight: 700;
            font-size: 20px;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .chat-header h2::before {
            content: '💬';
            font-size: 24px;
        }
        
        .chat-messages {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }
        
        .message {
            display: flex;
            margin-bottom: 16px;
            padding: 12px 16px;
            border-radius: 8px;
            transition: all 0.2s ease;
            position: relative;
        }
        
        .message:hover {
            background: linear-gradient(135deg, var(--discord-hover) 0%, #2c2f35 100%);
            transform: translateX(4px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .message:hover::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 3px;
            background: linear-gradient(135deg, var(--discord-accent), #4752c4);
            border-radius: 0 2px 2px 0;
        }
        
        .message-avatar {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            margin-right: 16px;
            flex-shrink: 0;
            overflow: hidden;
            border: 3px solid transparent;
            background: linear-gradient(135deg, var(--discord-accent), #4752c4);
            padding: 2px;
            transition: all 0.3s ease;
        }
        
        .message-avatar:hover {
            transform: scale(1.1);
            box-shadow: 0 0 16px rgba(88, 101, 242, 0.4);
        }
        
        .message-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 50%;
            background-color: var(--discord-header);
        }
        
        .message-content {
            flex: 1;
        }
        
        .message-header {
            display: flex;
            align-items: baseline;
            margin-bottom: 4px;
        }
        
        .message-username {
            font-weight: 700;
            margin-right: 8px;
            font-size: 16px;
            background: linear-gradient(135deg, #ffffff, var(--discord-light));
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            display: inline-block;
        }
        
        .message-timestamp {
            color: #72767d;
            font-size: 12px;
            font-weight: 500;
            opacity: 0.7;
            transition: opacity 0.2s ease;
        }
        
        .message:hover .message-timestamp {
            opacity: 1;
        }
        
        .message-text {
            color: var(--discord-text);
            font-size: 15px;
            line-height: 1.4;
            white-space: pre-wrap;
        }
        
        .loading {
            text-align: center;
            padding: 40px 20px;
            color: var(--discord-light);
            display: none;
            background: linear-gradient(135deg, rgba(88, 101, 242, 0.1), rgba(88, 101, 242, 0.05));
            border-radius: 12px;
            margin: 20px;
            border: 1px dashed var(--discord-accent);
        }
        
        .spinner {
            display: inline-block;
            width: 28px;
            height: 28px;
            border: 3px solid rgba(88, 101, 242, 0.3);
            border-radius: 50%;
            border-top-color: var(--discord-accent);
            animation: spin 1s ease-in-out infinite;
            margin-right: 12px;
            box-shadow: 0 0 8px rgba(88, 101, 242, 0.3);
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .error-message {
            color: var(--discord-red);
            margin-top: 12px;
            font-size: 14px;
            display: none;
            padding: 12px 16px;
            background: rgba(237, 66, 69, 0.1);
            border: 1px solid var(--discord-red);
            border-radius: 8px;
            font-weight: 500;
        }
        
        .success-message {
            color: var(--discord-green);
            margin-top: 12px;
            font-size: 14px;
            display: none;
            padding: 12px 16px;
            background: rgba(87, 242, 135, 0.1);
            border: 1px solid var(--discord-green);
            border-radius: 8px;
            font-weight: 500;
        }
        
        .content-settings, .advanced-settings {
            margin-top: 16px;
            padding: 16px;
            background: rgba(88, 101, 242, 0.05);
            border: 1px solid rgba(88, 101, 242, 0.2);
            border-radius: 8px;
            transition: all 0.3s ease;
        }
        
        .content-settings:hover, .advanced-settings:hover {
            background: rgba(88, 101, 242, 0.08);
            border-color: rgba(88, 101, 242, 0.3);
        }
        
        .content-settings label, .advanced-settings label {
            display: flex;
            align-items: center;
            margin: 0;
            cursor: pointer;
            transition: color 0.2s ease;
        }
        
        .content-settings label:hover, .advanced-settings label:hover {
            color: white;
        }
        
        input[type="checkbox"] {
            width: auto;
            margin: 0 8px 0 0;
            transform: scale(1.2);
            accent-color: var(--discord-accent);
        }
        
        #explicitNote, #advancedPanel {
            margin-top: 12px;
            padding: 12px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
            border-left: 3px solid var(--discord-yellow);
        }
        
        /* New styles for character management */
        .character-list {
            max-height: 220px;
            overflow-y: auto;
            border: 2px solid var(--discord-secondary);
            border-radius: 8px;
            margin-top: 12px;
            margin-bottom: 12px;
            background: linear-gradient(135deg, var(--discord-header) 0%, #1a1c1f 100%);
            scrollbar-width: thin;
            scrollbar-color: var(--discord-accent) transparent;
        }
        
        .character-list::-webkit-scrollbar {
            width: 6px;
        }
        
        .character-list::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .character-list::-webkit-scrollbar-thumb {
            background: var(--discord-accent);
            border-radius: 3px;
        }
        
        .character-item {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 1px solid rgba(79, 84, 92, 0.3);
            transition: all 0.2s ease;
            position: relative;
        }
        
        .character-item:last-child {
            border-bottom: none;
        }
        
        .character-item:hover {
            background: linear-gradient(135deg, var(--discord-hover) 0%, #2c2f35 100%);
            transform: translateX(4px);
        }
        
        .character-item:hover::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 3px;
            background: linear-gradient(135deg, var(--discord-accent), #4752c4);
        }
        
        .character-item.selected {
            background: linear-gradient(135deg, rgba(88, 101, 242, 0.3), rgba(71, 82, 196, 0.3));
            border-left: 3px solid var(--discord-accent);
        }
        
        .character-item-avatar {
            width: 30px; /* Updated from 36px */
            height: 30px; /* Updated from 36px */
            border-radius: 50%;
            margin-right: 12px;
            overflow: hidden;
            border: 2px solid var(--discord-accent);
            transition: transform 0.2s ease;
            flex-shrink: 0; /* Add to prevent avatar from growing/shrinking */
            display: flex; /* Add to ensure proper containment */
            align-items: center; /* Add to center the image */
            justify-content: center; /* Add to center the image */
        }
        
        .character-item:hover .character-item-avatar {
            transform: scale(1.1);
        }
        
        .character-item-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .character-item-name {
            flex: 1;
            font-weight: 600;
            color: var(--discord-text);
        }
        
        .character-item-delete {
            color: var(--discord-red);
            cursor: pointer;
            margin-left: 12px;
            font-size: 18px;
            font-weight: bold;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s ease;
        }
        
        .character-item-delete:hover {
            background: var(--discord-red);
            color: white;
            transform: scale(1.2);
        }
        
        .controls, .character-buttons, .multi-btn-row {
            margin-top: 16px;
            display: flex;
            gap: 12px;
        }
        
        .controls button, .character-buttons button, .multi-btn-row button {
            flex: 1;
        }
        
        .avatar-preview {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--discord-header) 0%, #1a1c1f 100%);
            margin-right: 12px;
            overflow: hidden;
            border: 3px solid var(--discord-accent);
            display: inline-block;
            transition: all 0.3s ease;
        }
        
        .avatar-preview:hover {
            transform: scale(1.05);
            box-shadow: 0 0 16px rgba(88, 101, 242, 0.4);
        }
        
        .avatar-preview img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .char-row {
            display: flex;
            align-items: center;
            margin-bottom: 16px;
            padding: 12px;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            border: 1px solid var(--discord-secondary);
        }
        
        /* Add some nice animations */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .setup-panel {
            animation: fadeIn 0.3s ease-out;
        }
        
        /* Custom file input styling */
        input[type="file"] {
            background: linear-gradient(135deg, var(--discord-accent) 0%, #4752c4 100%);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 10px 16px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        input[type="file"]:hover {
            background: linear-gradient(135deg, #4752c4 0%, #3c4bc7 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(88, 101, 242, 0.4);
        }
        
        input[type="file"]::file-selector-button {
            background: none;
            border: none;
            color: white;
            font-weight: 600;
            margin-right: 8px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="sidebar" id="sidebar">
        <div class="setup-panel">
            <h2>🔒 Privacy Notice</h2>
            <div class="setup-panel-content">
                <p style="font-size: 12px; color: #b9bbbe; line-height: 1.4; margin-bottom: 12px;">
                    <strong>Your data stays local:</strong> All characters and API settings are stored only in your browser's local storage. Nothing is sent to external servers except your API requests.
                </p>
                <p style="font-size: 12px; color: #b9bbbe; line-height: 1.4;">
                    <strong>API Security:</strong> Only use trusted API endpoints. Your API keys are stored locally and not transmitted anywhere except to your chosen endpoint.
                </p>
            </div>
        </div>
        
        <div class="setup-panel">
            <h2>📖 How to Use</h2>
            <div class="setup-panel-content">
                <div style="font-size: 12px; color: #b9bbbe; line-height: 1.4;">
                <p style="margin-bottom: 8px;"><strong>Demo Mode:</strong> Select "Demo Mode" from the API Provider dropdown to try the generator without needing an API key.</p>
                <p style="margin-bottom: 8px;"><strong>Quick Start:</strong> 1) Create characters with names and avatars, 2) Select two characters, 3) Enter a conversation topic, 4) Click generate.</p>
                <p style="margin-bottom: 8px;"><strong>Character Details:</strong> Add personality, background, and texting style for more realistic conversations.</p>
                <p style="margin-bottom: 8px;"><strong>Advanced Mode:</strong> Customize the AI's behavior with your own system prompt instructions.</p>
                <p><strong>Need Help?</strong> Ask Claude or another AI assistant for character ideas, topic suggestions, or troubleshooting.</p>
                </div>
            </div>
        </div>

        <div class="setup-panel">
            <h2>Grok API Setup</h2>
            <div class="setup-panel-content">
                <label for="apiKey">API Key</label>
            <input type="password" id="apiKey" placeholder="Enter your Grok API key">
            
            <label for="apiEndpoint">API Provider</label>
            <select id="apiEndpoint">
                <option value="test-mode">Demo Mode (No API Key Required)</option>
                <option value="https://api.openai.com/v1/chat/completions">OpenAI</option>
                <option value="https://api.x.ai/v1/chat/completions">Grok (xAI)</option>
                <option value="https://api.anthropic.com/v1/messages">Claude (Anthropic)</option>
                <option value="custom">Custom Endpoint</option>
            </select>
            
            <div style="margin-top: 8px; margin-bottom: 12px;">
                <label style="font-size: 11px; color: #72767d; text-transform: none; margin: 0;">Endpoint URL:</label>
                <div id="endpointDisplay" style="font-size: 12px; color: #b9bbbe; background: #2c2f33; padding: 8px 12px; border-radius: 6px; border: 1px solid #4f545c; word-break: break-all; font-family: 'Courier New', monospace;"></div>
            </div>
            
            <input type="text" id="customEndpoint" placeholder="Enter custom endpoint URL" style="display: none;">
            
            <label for="model">Model</label>
            <select id="model">
                <option value="">Select a model</option>
                <optgroup label="OpenAI">
                    <option value="gpt-4">GPT-4</option>
                    <option value="gpt-4o">GPT-4o</option>
                    <option value="gpt-4o-mini">GPT-4o Mini</option>
                    <option value="gpt-3.5-turbo">GPT-3.5 Turbo</option>
                </optgroup>
                <optgroup label="Grok">
                    <option value="grok-3" selected>Grok-3</option>
                    <option value="grok-beta">Grok Beta</option>
                </optgroup>
                <optgroup label="Claude">
                    <option value="claude-3-5-sonnet-20241022">Claude 3.5 Sonnet</option>
                    <option value="claude-3-5-haiku-20241022">Claude 3.5 Haiku</option>
                    <option value="claude-3-opus-20240229">Claude 3 Opus</option>
                </optgroup>
                <optgroup label="Other">
                    <option value="custom">Custom Model Name</option>
                </optgroup>
            </select>
            <input type="text" id="customModel" placeholder="Enter custom model name" style="display: none; margin-top: 8px;">
            
            <button id="saveApiSettings">Save API Settings</button>
            <div class="success-message" id="apiSuccessMsg">API settings saved successfully!</div>
            </div>
        </div>
        
        <div class="setup-panel">
            <h2>🔊 Voice Settings (ElevenLabs)</h2>
            <div class="setup-panel-content">
                <label for="elevenLabsApiKey">ElevenLabs API Key</label>
                <input type="password" id="elevenLabsApiKey" placeholder="Enter your ElevenLabs API key">
                
                <label>
                    <input type="checkbox" id="enableVoiceGeneration">
                    <span style="margin-left: 5px; font-size: 14px;">Enable voice generation</span>
                </label>
                
                <div id="voiceSettings" style="display: none; margin-top: 10px;">
                    <label for="voiceProvider">Voice Provider</label>
                    <select id="voiceProvider">
                        <option value="elevenlabs">ElevenLabs</option>
                    </select>
                    
                    <div class="info-text" style="font-size: 12px; color: #b9bbbe; margin-top: 8px;">
                        Voice selections for each character are configured in the Character Management section.
                    </div>
                </div>
                
                <button id="testVoiceApiBtn">Test Voice API</button>
                <div class="success-message" id="voiceApiSuccessMsg">Voice API connected successfully!</div>
                <div class="error-message" id="voiceApiErrorMsg"></div>
            </div>
        </div>
        
        <div class="setup-panel">
            <h2>Character Management</h2>
            <div class="setup-panel-content">
                <div id="characterSelector">
                    <label for="char1Selector">Character 1</label>
                    <select id="char1Selector">
                        <option value="">Select a character</option>
                    </select>
                    
                    <label for="char2Selector">Character 2</label>
                    <select id="char2Selector">
                        <option value="">Select a character</option>
                    </select>
                </div>
            
            <div class="char-setup">
                <h2>Add/Edit Character</h2>
                <div class="char-setup-content">
                    <div class="char-row">
                    <div class="avatar-preview" id="charEditPreview"></div>
                    <div style="flex: 1;">
                        <label for="charEditName">Character Name</label>
                        <input type="text" id="charEditName" placeholder="Character Name">
                    </div>
                </div>
                <input type="file" id="charEditAvatar" accept="image/*">
                
                <label for="charEditAge">Age</label>
                <input type="number" id="charEditAge" placeholder="Age (optional)" min="13" max="100">
                
                <label for="charEditPersonality">Personality Traits</label>
                <textarea id="charEditPersonality" placeholder="Describe their personality, quirks, and communication style..." rows="3"></textarea>
                
                <label for="charEditBackground">Background/Occupation</label>
                <input type="text" id="charEditBackground" placeholder="Job, hobbies, background info...">
                
                <label for="charEditRelationship">Relationship to Other Character</label>
                <select id="charEditRelationship">
                    <option value="">Select relationship</option>
                    <option value="friend">Friend</option>
                    <option value="best-friend">Best Friend</option>
                    <option value="romantic-partner">Romantic Partner</option>
                    <option value="spouse">Spouse/Married</option>
                    <option value="sibling">Sibling</option>
                    <option value="parent">Parent</option>
                    <option value="child">Child</option>
                    <option value="coworker">Coworker</option>
                    <option value="classmate">Classmate</option>
                    <option value="roommate">Roommate</option>
                    <option value="neighbor">Neighbor</option>
                    <option value="acquaintance">Acquaintance</option>
                    <option value="stranger">Stranger</option>
                    <option value="ex">Ex-partner</option>
                    <option value="other">Other</option>
                </select>
                
                <label for="charEditTextingStyle">Texting Style</label>
                <select id="charEditTextingStyle">
                    <option value="">Select texting style</option>
                    <option value="proper">Proper grammar and punctuation</option>
                    <option value="casual">Casual, some abbreviations</option>
                    <option value="shorthand">Lots of abbreviations (u, ur, etc.)</option>
                    <option value="no-caps">all lowercase, no caps</option>
                    <option value="emoji-heavy">Uses lots of emojis 😊</option>
                    <option value="minimal">Very brief responses</option>
                    <option value="verbose">Long, detailed messages</option>
                    <option value="typos">Makes typos, auto-correct errors</option>
                </select>
                
                <div class="multi-btn-row">
                    <button id="saveCharBtn">Save Character</button>
                    <button id="clearFormBtn">Clear Form</button>
                </div>
                <div class="success-message" id="charSuccessMsg">Character saved successfully!</div>
                </div>
            </div>
            
            <div class="char-setup">
                <h2>Import/Export Characters</h2>
                <div class="char-setup-content">
                    <div class="multi-btn-row">
                    <button id="exportCharsBtn">Export All Characters</button>
                    <button id="importCharsBtn">Import Characters</button>
                </div>
                <input type="file" id="importCharsFile" accept=".json" style="display: none;">
                <div style="font-size: 11px; color: #72767d; margin-top: 8px;">
                    Export creates a JSON file with all your characters. Import merges with existing characters.
                </div>
                <div class="success-message" id="importSuccessMsg">Characters imported successfully!</div>
                <div class="error-message" id="importErrorMsg">Error importing characters. Please check the file format.</div>
                </div>
            </div>
            
            <div class="char-setup">
                <h2>Saved Characters</h2>
                <div class="char-setup-content">
                    <div class="character-list" id="savedCharacters">
                    <!-- Character items will be added here -->
                </div>
                </div>
            </div>
            </div>
        </div>
        
        <div class="setup-panel">
            <h2>Conversation Setup</h2>
            <div class="setup-panel-content">
                <label for="conversationMode">Conversation Mode</label>
                <select id="conversationMode">
                    <option value="text">Text Messages</option>
                    <option value="inperson">In Person</option>
                    <option value="phone">Phone Call</option>
                    <option value="social">Social Media</option>
                </select>
                
                <label for="topic">Conversation Topic</label>
            <textarea id="topic" placeholder="Describe what the conversation should be about..."></textarea>
            
            <label for="messageCount">Number of Messages</label>
            <input type="number" id="messageCount" min="2" max="50" value="10">
            
            <div class="advanced-settings" style="margin-top: 15px;">
                <label>
                    <input type="checkbox" id="advancedMode">
                    <span style="margin-left: 5px; font-size: 14px;">Advanced Mode</span>
                </label>
                <div id="advancedPanel" style="display: none; margin-top: 10px;">
                    <label for="systemPrompt">Custom User Message</label>
                    <button id="autofillPromptBtn" style="float: right; padding: 4px 8px; font-size: 12px; background-color: #5865F2;">Autofill Default</button>
                    <div style="clear: both; margin-top: 5px;">
                        <label>
                            <input type="checkbox" id="replaceEntirePrompt">
                            <span style="margin-left: 5px; font-size: 13px;">Replace entire API message (overrides all settings)</span>
                        </label>
                    </div>
                    <div style="font-size: 12px; color: #8b949e; margin-bottom: 5px; margin-top: 5px;">
                        When "Replace entire API message" is checked, this becomes the exact message sent to the AI. Otherwise, it works with other settings.
                    </div>
                    <textarea id="systemPrompt" placeholder="Enter custom message to send to the AI..." rows="6"></textarea>
                    
                    <label for="char1InitialMsg" style="margin-top: 10px;">Character 1 Initial Message</label>
                    <textarea id="char1InitialMsg" placeholder="Optional: First message by character 1..." rows="2"></textarea>
                    
                    <label for="char2InitialMsg" style="margin-top: 10px;">Character 2 Initial Message</label>
                    <textarea id="char2InitialMsg" placeholder="Optional: First message by character 2..." rows="2"></textarea>
                    
                    
                </div>
            </div>
            
            <button id="generateBtn">Generate Conversation</button>
            <button id="continueBtn" style="margin-left: 10px; background-color: #5865F2;">Continue Conversation</button>
            <div class="error-message" id="errorMsg"></div>
            </div>
        </div>
        
        <div class="setup-panel">
            <h2>Terms of Use</h2>
            <div class="setup-panel-content">
                <p style="font-size: 12px; color: #b9bbbe; line-height: 1.4; margin-bottom: 8px;">
                <strong>Responsible Use:</strong> Users are responsible for all generated content and must comply with applicable laws and platform policies.
            </p>
            <p style="font-size: 12px; color: #b9bbbe; line-height: 1.4; margin-bottom: 8px;">
                <strong>Content Guidelines:</strong> Generated conversations should be appropriate and respectful. Do not use this tool to create harmful, harassing, or illegal content.
            </p>
            <p style="font-size: 12px; color: #b9bbbe; line-height: 1.4;">
                <strong>Made with:</strong> This tool was created with assistance from Claude AI by Anthropic. For questions or help setting up characters, you can ask Claude or another AI assistant.
            </p>
            </div>
        </div>
        
        <div class="setup-panel">
            <h2>Export & Audio Options</h2>
            <div class="setup-panel-content">
                <div class="multi-btn-row">
                <button id="downloadFullBtn">Download Full Generator</button>
                <button id="downloadChatOnlyBtn">Download Chat</button>
                </div>
                
                <div id="voiceGenerationSection" style="margin-top: 16px; display: none;">
                    <h3 style="font-size: 14px; margin-bottom: 12px;">🔊 Generate Audio</h3>
                    
                    <div id="voiceAssignmentSection" style="margin-bottom: 16px;">
                        <h4 style="font-size: 13px; margin-bottom: 8px;">Voice Assignment</h4>
                        <div class="voice-assignment" style="margin-bottom: 12px;">
                            <label id="char1VoiceLabel" style="font-size: 12px; margin-bottom: 4px;">Character 1:</label>
                            <select id="char1Voice" style="margin-bottom: 8px;">
                                <option value="">Auto-assign</option>
                                <optgroup label="Female Voices">
                                    <option value="21m00Tcm4TlvDq8ikWAM">Rachel (friendly)</option>
                                    <option value="EXAVITQu4vr4xnSDxMaL">Bella (young)</option>
                                    <option value="MF3mGyEYCl7XYWbV9V6O">Elli (emotional)</option>
                                    <option value="pNInz6obpgDQGcFmaJgB">Nicole (whispery)</option>
                                </optgroup>
                                <optgroup label="Male Voices">
                                    <option value="29vD33N1CtxCmqQRPOHJ">Drew (casual)</option>
                                    <option value="ErXwobaYiN019PkySvjV">Antoni (mature)</option>
                                    <option value="TxGEqnHWrfWFTfGW9XjX">Josh (deep)</option>
                                    <option value="VR6AewLTigWG4xSOukaG">Arnold (older)</option>
                                    <option value="5Q0t7uMcjvnagumLfvZi">Callum (hoarse)</option>
                                </optgroup>
                                <optgroup label="Neutral Voices">
                                    <option value="yoZ06aMxZJJ28mfd3POQ">Sam (neutral)</option>
                                    <option value="SOYHLrjzK2X1ezoPC6cr">Harry (anxious)</option>
                                </optgroup>
                            </select>
                        </div>
                        <div class="voice-assignment" style="margin-bottom: 12px;">
                            <label id="char2VoiceLabel" style="font-size: 12px; margin-bottom: 4px;">Character 2:</label>
                            <select id="char2Voice">
                                <option value="">Auto-assign</option>
                                <optgroup label="Female Voices">
                                    <option value="21m00Tcm4TlvDq8ikWAM">Rachel (friendly)</option>
                                    <option value="EXAVITQu4vr4xnSDxMaL">Bella (young)</option>
                                    <option value="MF3mGyEYCl7XYWbV9V6O">Elli (emotional)</option>
                                    <option value="pNInz6obpgDQGcFmaJgB">Nicole (whispery)</option>
                                </optgroup>
                                <optgroup label="Male Voices">
                                    <option value="29vD33N1CtxCmqQRPOHJ">Drew (casual)</option>
                                    <option value="ErXwobaYiN019PkySvjV">Antoni (mature)</option>
                                    <option value="TxGEqnHWrfWFTfGW9XjX">Josh (deep)</option>
                                    <option value="VR6AewLTigWG4xSOukaG">Arnold (older)</option>
                                    <option value="5Q0t7uMcjvnagumLfvZi">Callum (hoarse)</option>
                                </optgroup>
                                <optgroup label="Neutral Voices">
                                    <option value="yoZ06aMxZJJ28mfd3POQ">Sam (neutral)</option>
                                    <option value="SOYHLrjzK2X1ezoPC6cr">Harry (anxious)</option>
                                </optgroup>
                            </select>
                        </div>
                    </div>
                    
                    <div class="multi-btn-row">
                        <button id="generateAudioBtn" class="primary-btn">Generate Voice Audio</button>
                        <button id="downloadAudioBtn" style="display: none;">Download Audio</button>
                    </div>
                    <div class="progress-bar" id="audioProgressBar" style="display: none;">
                        <div class="progress-fill"></div>
                    </div>
                    <div id="audioPlayerContainer" style="margin-top: 12px; display: none;">
                        <audio id="generatedAudio" controls style="width: 100%;"></audio>
                    </div>
                    <div class="info-text" id="audioGenerationInfo" style="font-size: 12px; color: #b9bbbe; margin-top: 8px;"></div>
                    <div class="error-message" id="audioErrorMsg"></div>
                </div>
            </div>
        </div>
        
        <div class="setup-panel">
            <h2>Troubleshooting</h2>
            <div class="setup-panel-content">
                <p style="font-size: 12px; margin-bottom: 10px;">
                <strong>401 Errors:</strong> Verify your API key is correct and has the proper permissions.
            </p>
            <p style="font-size: 12px; margin-bottom: 10px;">
                <strong>Network Errors:</strong> The browser may be blocked from accessing the API due to:
            </p>
            <ul style="font-size: 12px; margin-left: 15px; margin-bottom: 10px;">
                <li>CORS restrictions (browser security)</li>
                <li>Incorrect API endpoint</li>
                <li>API service being down or requiring VPN</li>
            </ul>
            <p style="font-size: 12px; margin-bottom: 10px;">
                <strong>Alternative Solution:</strong> You may need to use an OpenAI API key with an OpenAI-compatible endpoint.
            </p>
            <p style="font-size: 12px;">
                Check the browser console (F12) for detailed error information.
            </p>
            </div>
        </div>
    </div>
    
    <div class="main-content">
        <div class="chat-header">
            <h2>Chat Preview</h2>
        </div>
        
        <div class="chat-messages" id="chatMessages">
            <div class="message">
                <div class="message-avatar">
                    <img src="/api/placeholder/40/40" alt="Default avatar">
                </div>
                <div class="message-content">
                    <div class="message-header">
                        <div class="message-username">System</div>
                        <div class="message-timestamp">Today at 12:00 PM</div>
                    </div>
                    <div class="message-text">Configure your settings in the sidebar and click "Generate Conversation" to create a chat.</div>
                </div>
            </div>
        </div>
        
        <div class="loading" id="loadingIndicator">
            <div class="spinner"></div>
            <span>Generating conversation with Grok API...</span>
        </div>
    </div>

    <script>
        // Persistent storage helper functions
        const storage = {
            saveApiSettings: function() {
                const modelSelect = document.getElementById('model');
                const customModelField = document.getElementById('customModel');
                
                // Get the actual model name
                let modelValue;
                if (modelSelect.value === 'custom') {
                    modelValue = customModelField.value;
                } else {
                    modelValue = modelSelect.value;
                }
                
                const settings = {
                    apiKey: document.getElementById('apiKey').value,
                    endpoint: document.getElementById('apiEndpoint').value,
                    customEndpoint: document.getElementById('customEndpoint').value,
                    model: modelValue
                };
                localStorage.setItem('grokApiSettings', JSON.stringify(settings));
                
                // Show success message
                const successMsg = document.getElementById('apiSuccessMsg');
                successMsg.style.display = 'block';
                setTimeout(() => {
                    successMsg.style.display = 'none';
                }, 3000);
            },
            
            loadApiSettings: function() {
                const settings = JSON.parse(localStorage.getItem('grokApiSettings') || '{}');
                if (settings.apiKey) document.getElementById('apiKey').value = settings.apiKey;
                if (settings.endpoint) {
                    document.getElementById('apiEndpoint').value = settings.endpoint;
                    
                    // Trigger change event to update UI state
                    document.getElementById('apiEndpoint').dispatchEvent(new Event('change'));
                }
                if (settings.customEndpoint) document.getElementById('customEndpoint').value = settings.customEndpoint;
                if (settings.model) {
                    const modelSelect = document.getElementById('model');
                    const customModelField = document.getElementById('customModel');
                    
                    // Check if the saved model exists in our predefined options
                    const modelExists = Array.from(modelSelect.options).some(option => option.value === settings.model);
                    
                    if (modelExists) {
                        modelSelect.value = settings.model;
                    } else {
                        // If it's a custom model, set to custom and fill the custom field
                        modelSelect.value = 'custom';
                        customModelField.value = settings.model;
                        customModelField.style.display = 'block';
                    }
                }
                
                // Show custom endpoint field if needed
                if (settings.endpoint === 'custom') {
                    document.getElementById('customEndpoint').style.display = 'block';
                }
                
                // Update endpoint display (will be handled by the change event above)
            },
            
            // Character storage functions
            getCharacters: function() {
                return JSON.parse(localStorage.getItem('grokCharacters') || '[]');
            },
            
            saveCharacter: function(character) {
                // Check if character has a very large avatar (data URL)
                if (character.avatar && character.avatar.length > 100000) {
                    // Create a function to generate a thumbnail if avatar is too large
                    const createThumbnail = (imgDataUrl, maxWidth, maxHeight, callback) => {
                        const img = new Image();
                        img.onload = function() {
                            let width = img.width;
                            let height = img.height;
                            
                            // Calculate the new dimensions to maintain aspect ratio
                            if (width > height) {
                                if (width > maxWidth) {
                                    height *= maxWidth / width;
                                    width = maxWidth;
                                }
                            } else {
                                if (height > maxHeight) {
                                    width *= maxHeight / height;
                                    height = maxHeight;
                                }
                            }
                            
                            // Create a canvas element to resize the image
                            const canvas = document.createElement('canvas');
                            canvas.width = width;
                            canvas.height = height;
                            
                            // Draw the resized image on the canvas
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(img, 0, 0, width, height);
                            
                            // Convert canvas to data URL (with compression)
                            const thumbDataUrl = canvas.toDataURL('image/jpeg', 0.7);
                            callback(thumbDataUrl);
                        };
                        img.src = imgDataUrl;
                    };
                    
                    // Process the avatar asynchronously and continue with saving
                    createThumbnail(character.avatar, 100, 100, (thumbnailDataUrl) => {
                        character.avatar = thumbnailDataUrl;
                        this._saveCharacterToStorage(character);
                    });
                } else {
                    // Avatar is already small enough or doesn't exist, save directly
                    this._saveCharacterToStorage(character);
                }
            },
            
            deleteCharacter: function(id) {
                let characters = this.getCharacters();
                characters = characters.filter(c => c.id !== id);
                localStorage.setItem('grokCharacters', JSON.stringify(characters));
                this.updateCharacterSelectors();
                this.renderCharacterList();
            },
            
            renderCharacterList: function() {
                const characters = this.getCharacters();
                const listElement = document.getElementById('savedCharacters');
                listElement.textContent = '';
                
                if (characters.length === 0) {
                    const emptyDiv = document.createElement('div');
                    emptyDiv.style.padding = '10px';
                    emptyDiv.style.color = '#72767d';
                    emptyDiv.textContent = 'No saved characters';
                    listElement.appendChild(emptyDiv);
                    return;
                }
                
                characters.forEach(char => {
                    const charItem = document.createElement('div');
                    charItem.className = 'character-item';
                    charItem.dataset.id = char.id;
                    
                    const charItemAvatar = document.createElement('div');
                    charItemAvatar.className = 'character-item-avatar';
                    
                    const avatar = document.createElement('img');
                    // Use our centralized security utility instead of inline validation
                    avatar.src = securityUtils.sanitizeUrl(char.avatar, '/api/placeholder/30/30');
                    avatar.alt = char.name;
                    avatar.style.width = '30px';
                    avatar.style.height = '30px';
                    avatar.style.objectFit = 'cover';
                    charItemAvatar.appendChild(avatar);
                    
                    const charItemName = document.createElement('div');
                    charItemName.className = 'character-item-name';
                    charItemName.textContent = char.name;
                    
                    const charItemDelete = document.createElement('div');
                    charItemDelete.className = 'character-item-delete';
                    charItemDelete.textContent = '×';
                    
                    charItem.appendChild(charItemAvatar);
                    charItem.appendChild(charItemName);
                    charItem.appendChild(charItemDelete);
                    
                    charItem.addEventListener('click', function(e) {
                        if (e.target.classList.contains('character-item-delete')) {
                            if (confirm('Delete character "' + char.name + '"?')) {
                                storage.deleteCharacter(char.id);
                            }
                            return;
                        }
                        
                        storage.editCharacter(char.id);
                    });
                    
                    listElement.appendChild(charItem);
                });
            },
            
            updateCharacterSelectors: function() {
                const characters = this.getCharacters();
                const selector1 = document.getElementById('char1Selector');
                const selector2 = document.getElementById('char2Selector');
                
                // Save current selections
                const selectedChar1 = selector1.value;
                const selectedChar2 = selector2.value;
                
                // Clear current options except first one
                selector1.textContent = '';
                selector2.textContent = '';
                
                // Add default option
                const defaultOption1 = document.createElement('option');
                defaultOption1.value = '';
                defaultOption1.textContent = 'Select a character';
                
                const defaultOption2 = document.createElement('option');
                defaultOption2.value = '';
                defaultOption2.textContent = 'Select a character';
                
                selector1.appendChild(defaultOption1);
                selector2.appendChild(defaultOption2);
                
                // Add character options
                characters.forEach(char => {
                    const option1 = document.createElement('option');
                    option1.value = char.id;
                    option1.textContent = char.name;
                    selector1.appendChild(option1);
                    
                    const option2 = document.createElement('option');
                    option2.value = char.id;
                    option2.textContent = char.name;
                    selector2.appendChild(option2);
                });
                
                // Restore selections if possible
                if (selectedChar1 && characters.some(c => c.id === selectedChar1)) {
                    selector1.value = selectedChar1;
                }
                
                if (selectedChar2 && characters.some(c => c.id === selectedChar2)) {
                    selector2.value = selectedChar2;
                }
            },
            
            // Export all characters to JSON file
            exportCharacters: function() {
                const characters = this.getCharacters();
                if (characters.length === 0) {
                    alert('No characters to export');
                    return;
                }
                
                const dataStr = JSON.stringify(characters, null, 2);
                const blob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `dialogue-characters-${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 0);
            },
            
            // Import characters from JSON file
            importCharacters: function(file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const importedChars = JSON.parse(e.target.result);
                        
                        if (!Array.isArray(importedChars)) {
                            throw new Error('Invalid file format');
                        }
                        
                        // Validate character structure
                        const validChars = importedChars.filter(char => 
                            char.id && char.name && typeof char.name === 'string'
                        );
                        
                        if (validChars.length === 0) {
                            throw new Error('No valid characters found in file');
                        }
                        
                        // Merge with existing characters (avoid duplicates by ID)
                        const existingChars = this.getCharacters();
                        const mergedChars = [...existingChars];
                        
                        validChars.forEach(importedChar => {
                            const existingIndex = mergedChars.findIndex(c => c.id === importedChar.id);
                            if (existingIndex !== -1) {
                                // Update existing character
                                mergedChars[existingIndex] = importedChar;
                            } else {
                                // Add new character
                                mergedChars.push(importedChar);
                            }
                        });
                        
                        // Save merged characters
                        localStorage.setItem('grokCharacters', JSON.stringify(mergedChars));
                        this.updateCharacterSelectors();
                        this.renderCharacterList();
                        
                        // Show success message
                        const successMsg = document.getElementById('importSuccessMsg');
                        successMsg.style.display = 'block';
                        setTimeout(() => {
                            successMsg.style.display = 'none';
                        }, 3000);
                        
                    } catch (error) {
                        console.error('Import error:', error);
                        const errorMsg = document.getElementById('importErrorMsg');
                        errorMsg.textContent = `Error importing characters: ${error.message}`;
                        errorMsg.style.display = 'block';
                        setTimeout(() => {
                            errorMsg.style.display = 'none';
                        }, 5000);
                    }
                };
                reader.readAsText(file);
            },
            
            editCharacter: function(id) {
                const characters = this.getCharacters();
                const char = characters.find(c => c.id === id);
                if (!char) return;
                
                // URL validation function
                const isValidUrl = (url) => {
                    if (!url) return false;
                    try {
                        const parsedUrl = new URL(url, window.location.origin);
                        return parsedUrl.protocol === 'http:' || 
                               parsedUrl.protocol === 'https:' || 
                               url.startsWith('data:image/');
                    } catch (e) {
                        return false;
                    }
                };
                
                // Populate form fields with character data
                document.getElementById('charEditName').value = char.name;
                document.getElementById('charEditAge').value = char.age || '';
                document.getElementById('charEditPersonality').value = char.personality || '';
                document.getElementById('charEditBackground').value = char.background || '';
                document.getElementById('charEditRelationship').value = char.relationship || '';
                document.getElementById('charEditTextingStyle').value = char.textingStyle || '';
                
                const preview = document.getElementById('charEditPreview');
                preview.textContent = '';
                if (char.avatar) {
                    const img = document.createElement('img');
                    // Use our centralized security utility instead of inline validation
                    img.src = securityUtils.sanitizeUrl(char.avatar, '/api/placeholder/100/100');
                    img.alt = char.name;
                    img.style.width = '100%';
                    img.style.height = '100%';
                    img.style.objectFit = 'cover';
                    preview.appendChild(img);
                }
                
                // Store the current editing character ID
                preview.dataset.charId = char.id;
            },
            
            // Private method to save character to storage after image processing
            _saveCharacterToStorage: function(character) {
                const characters = this.getCharacters();
                const index = characters.findIndex(c => c.id === character.id);
                
                if (index !== -1) {
                    characters[index] = character;
                } else {
                    characters.push(character);
                }
                
                localStorage.setItem('grokCharacters', JSON.stringify(characters));
                this.updateCharacterSelectors();
                this.renderCharacterList();
            }
        };
        
        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            // Load saved API settings
            storage.loadApiSettings();
            
            // Load saved characters
            storage.renderCharacterList();
            storage.updateCharacterSelectors();
            
            // Initialize endpoint display
            const endpointSelect = document.getElementById('apiEndpoint');
            const endpointDisplay = document.getElementById('endpointDisplay');
            if (endpointSelect.value !== 'custom') {
                endpointDisplay.textContent = endpointSelect.value;
            } else {
                endpointDisplay.textContent = 'Select an endpoint above';
                endpointDisplay.style.color = '#72767d';
                endpointDisplay.style.fontStyle = 'italic';
            }
            
            // Initialize panel collapse functionality
            const setupPanels = document.querySelectorAll('.setup-panel');
            setupPanels.forEach(panel => {
                // Only get the direct h2 child, not nested ones
                const header = Array.from(panel.children).find(child => child.tagName === 'H2');
                if (header) {
                    header.addEventListener('click', function() {
                        panel.classList.toggle('collapsed');
                    });
                }
            });
            
            // Initialize internal section collapse functionality
            const charSetups = document.querySelectorAll('.char-setup');
            charSetups.forEach(setup => {
                const header = setup.querySelector('h2');
                if (header) {
                    header.addEventListener('click', function() {
                        setup.classList.toggle('collapsed');
                    });
                }
            });
        });
        
        // Handle explicit content toggle
        // Removed explicit content functionality

        // Handle advanced mode toggle
        document.getElementById('advancedMode').addEventListener('change', function() {
            const advancedPanel = document.getElementById('advancedPanel');
            if (this.checked) {
                advancedPanel.style.display = 'block';
            } else {
                advancedPanel.style.display = 'none';
            }
        });
        document.getElementById('apiEndpoint').addEventListener('change', function() {
            const customEndpointField = document.getElementById('customEndpoint');
            const endpointDisplay = document.getElementById('endpointDisplay');
            const apiKeyField = document.getElementById('apiKey');
            
            if (this.value === 'custom') {
                customEndpointField.style.display = 'block';
                endpointDisplay.textContent = 'Enter custom URL below';
                endpointDisplay.style.color = '#72767d';
                endpointDisplay.style.fontStyle = 'italic';
                apiKeyField.disabled = false;
            } else if (this.value === 'test-mode') {
                customEndpointField.style.display = 'none';
                endpointDisplay.textContent = 'Demo mode - generates sample conversations locally';
                endpointDisplay.style.color = '#57f287';
                endpointDisplay.style.fontStyle = 'italic';
                apiKeyField.disabled = true;
                apiKeyField.value = '';
            } else {
                customEndpointField.style.display = 'none';
                endpointDisplay.textContent = this.value;
                endpointDisplay.style.color = '#b9bbbe';
                endpointDisplay.style.fontStyle = 'normal';
                apiKeyField.disabled = false;
            }
        });
        
        document.getElementById('customEndpoint').addEventListener('input', function() {
            const endpointDisplay = document.getElementById('endpointDisplay');
            if (this.value.trim()) {
                endpointDisplay.textContent = this.value;
                endpointDisplay.style.color = '#b9bbbe';
                endpointDisplay.style.fontStyle = 'normal';
            } else {
                endpointDisplay.textContent = 'Enter custom URL below';
                endpointDisplay.style.color = '#72767d';
                endpointDisplay.style.fontStyle = 'italic';
            }
        });
        
        document.getElementById('model').addEventListener('change', function() {
            const customModelField = document.getElementById('customModel');
            if (this.value === 'custom') {
                customModelField.style.display = 'block';
            } else {
                customModelField.style.display = 'none';
            }
        });
        
        // Save API Settings
        document.getElementById('saveApiSettings').addEventListener('click', function() {
            storage.saveApiSettings();
        });
        
        // Handle file uploads for character avatar
        document.getElementById('charEditAvatar').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    // Create thumbnail from the uploaded image
                    const createThumbnail = (imgDataUrl, maxWidth, maxHeight, callback) => {
                        const img = new Image();
                        img.onload = function() {
                            let width = img.width;
                            let height = img.height;
                            
                            // Calculate the new dimensions to maintain aspect ratio
                            if (width > height) {
                                if (width > maxWidth) {
                                    height *= maxWidth / width;
                                    width = maxWidth;
                                }
                            } else {
                                if (height > maxHeight) {
                                    width *= maxHeight / height;
                                    height = maxHeight;
                                }
                            }
                            
                            // Create a canvas element to resize the image
                            const canvas = document.createElement('canvas');
                            canvas.width = width;
                            canvas.height = height;
                            
                            // Draw the resized image on the canvas
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(img, 0, 0, width, height);
                            
                            // Convert canvas to data URL (with compression)
                            const thumbDataUrl = canvas.toDataURL('image/jpeg', 0.7);
                            callback(thumbDataUrl);
                        };
                        img.src = imgDataUrl;
                    };
                    
                    // Generate thumbnail
                    createThumbnail(event.target.result, 150, 150, (thumbnailDataUrl) => {
                        const preview = document.getElementById('charEditPreview');
                        preview.textContent = '';
                        const img = document.createElement('img');
                        img.src = thumbnailDataUrl;
                        img.alt = 'Character Preview';
                        preview.appendChild(img);
                    });
                };
                reader.readAsDataURL(file);
            }
        });
        
        // Save Character
        document.getElementById('saveCharBtn').addEventListener('click', function() {
            const nameInput = document.getElementById('charEditName');
            const ageInput = document.getElementById('charEditAge');
            const personalityInput = document.getElementById('charEditPersonality');
            const backgroundInput = document.getElementById('charEditBackground');
            const relationshipInput = document.getElementById('charEditRelationship');
            const textingStyleInput = document.getElementById('charEditTextingStyle');
            const preview = document.getElementById('charEditPreview');
            const avatarImg = preview.querySelector('img');
            
            if (!nameInput.value.trim()) {
                alert('Please enter a character name');
                return;
            }
            
            // Get character ID (or generate new one)
            const charId = preview.dataset.charId || 'char_' + Date.now();
            
            // Create character object
            const character = {
                id: charId,
                name: nameInput.value.trim(),
                age: ageInput.value ? parseInt(ageInput.value) : null,
                personality: personalityInput.value.trim(),
                background: backgroundInput.value.trim(),
                relationship: relationshipInput.value,
                textingStyle: textingStyleInput.value,
                avatar: avatarImg ? avatarImg.src : null
            };
            
            // Save character
            storage.saveCharacter(character);
            
            // Show success message
            const successMsg = document.getElementById('charSuccessMsg');
            successMsg.style.display = 'block';
            setTimeout(() => {
                successMsg.style.display = 'none';
            }, 3000);
            
            // Clear form
            document.getElementById('clearFormBtn').click();
        });
        
        // Clear character form
        document.getElementById('clearFormBtn').addEventListener('click', function() {
            document.getElementById('charEditName').value = '';
            document.getElementById('charEditAge').value = '';
            document.getElementById('charEditPersonality').value = '';
            document.getElementById('charEditBackground').value = '';
            document.getElementById('charEditRelationship').value = '';
            document.getElementById('charEditTextingStyle').value = '';
            document.getElementById('charEditPreview').textContent = '';
            document.getElementById('charEditPreview').dataset.charId = '';
            document.getElementById('charEditAvatar').value = '';
        });
        
        // Export Characters
        document.getElementById('exportCharsBtn').addEventListener('click', function() {
            storage.exportCharacters();
        });
        
        // Import Characters
        document.getElementById('importCharsBtn').addEventListener('click', function() {
            // Show warning dialog before opening file picker
            const confirmation = confirm(
                "⚠️ SECURITY WARNING - Import Characters\n\n" +
                "DANGER: Only import character files from sources you completely trust!\n\n" +
                "Risks of importing untrusted files:\n" +
                "• Malicious code execution in your browser\n" +
                "• Theft of personal data or API keys\n" +
                "• Corruption of your saved characters\n" +
                "• Potential security vulnerabilities\n\n" +
                "NEVER import files from:\n" +
                "• Unknown websites or downloads\n" +
                "• Email attachments from strangers\n" +
                "• Untrusted online sources\n\n" +
                "Characters with duplicate IDs will overwrite existing ones.\n\n" +
                "Are you absolutely sure this file is from a trusted source and safe to import?"
            );
            
            if (confirmation) {
                document.getElementById('importCharsFile').click();
            }
        });
        
        document.getElementById('importCharsFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                storage.importCharacters(file);
                // Clear the file input so the same file can be selected again
                e.target.value = '';
            }
        });
        
        // Add missing character preview elements
        const setupPanel = document.querySelector('.setup-panel');
        // Add hidden character name inputs and previews to the DOM
        if (!document.getElementById('char1Name')) {
            const hiddenElements = document.createElement('div');
            hiddenElements.style.display = 'none';
            
            // Create elements using DOM API instead of innerHTML
            const char1Input = document.createElement('input');
            char1Input.type = 'text';
            char1Input.id = 'char1Name';
            
            const char2Input = document.createElement('input');
            char2Input.type = 'text';
            char2Input.id = 'char2Name';
            
            const char1Preview = document.createElement('div');
            char1Preview.id = 'char1Preview';
            
            const char2Preview = document.createElement('div');
            char2Preview.id = 'char2Preview';
            
            // Append all elements to the container
            hiddenElements.appendChild(char1Input);
            hiddenElements.appendChild(char2Input);
            hiddenElements.appendChild(char1Preview);
            hiddenElements.appendChild(char2Preview);
            
            setupPanel.appendChild(hiddenElements);
        }

        // Handle character selection
        document.getElementById('char1Selector').addEventListener('change', function() {
            const characters = storage.getCharacters();
            const selectedChar = characters.find(c => c.id === this.value);
            
            if (selectedChar) {
                // Set character 1 avatar and name
                document.getElementById('char1Preview').textContent = '';
                const img = document.createElement('img');
                // Use our centralized security utility instead of inline validation
                img.src = securityUtils.sanitizeUrl(selectedChar.avatar, '/api/placeholder/40/40');
                img.alt = selectedChar.name;
                img.style.width = '40px';
                img.style.height = '40px';
                img.style.objectFit = 'cover';
                img.style.borderRadius = '50%';
                document.getElementById('char1Preview').appendChild(img);
                document.getElementById('char1Name').value = selectedChar.name;
            } else {
                document.getElementById('char1Preview').textContent = '';
                document.getElementById('char1Name').value = '';
            }
        });
        
        document.getElementById('char2Selector').addEventListener('change', function() {
            const characters = storage.getCharacters();
            const selectedChar = characters.find(c => c.id === this.value);
            
            if (selectedChar) {
                // Set character 2 avatar and name
                document.getElementById('char2Preview').textContent = '';
                const img = document.createElement('img');
                // Use our centralized security utility instead of inline validation
                img.src = securityUtils.sanitizeUrl(selectedChar.avatar, '/api/placeholder/40/40');
                img.alt = selectedChar.name;
                img.style.width = '40px';
                img.style.height = '40px';
                img.style.objectFit = 'cover';
                img.style.borderRadius = '50%';
                document.getElementById('char2Preview').appendChild(img);
                document.getElementById('char2Name').value = selectedChar.name;
            } else {
                document.getElementById('char2Preview').textContent = '';
                document.getElementById('char2Name').value = '';
            }
        });
        
        // Generate conversation button
        document.getElementById('generateBtn').addEventListener('click', async function() {
            const apiKey = document.getElementById('apiKey').value;
            const char1Selector = document.getElementById('char1Selector');
            const char2Selector = document.getElementById('char2Selector');
            
            // Get character names from selectors
            let char1Name = 'Character 1';
            let char2Name = 'Character 2';
            
            if (char1Selector.value) {
                const characters = storage.getCharacters();
                const char1 = characters.find(c => c.id === char1Selector.value);
                if (char1) char1Name = char1.name;
            }
            
            if (char2Selector.value) {
                const characters = storage.getCharacters();
                const char2 = characters.find(c => c.id === char2Selector.value);
                if (char2) char2Name = char2.name;
            }
            
            // Set the hidden input fields with character names
            document.getElementById('char1Name').value = char1Name;
            document.getElementById('char2Name').value = char2Name;
            
            const topic = document.getElementById('topic').value;
            const messageCount = document.getElementById('messageCount').value || 10;
            
            const errorMsg = document.getElementById('errorMsg');
            errorMsg.style.display = 'none';
            
            // Check if demo mode is selected
            const isTestMode = document.getElementById('apiEndpoint').value === 'test-mode';
            
            if (!isTestMode && !apiKey) {
                errorMsg.textContent = 'Please enter your API key or select Demo Mode';
                errorMsg.style.display = 'block';
                return;
            }
            
            if (!topic) {
                errorMsg.textContent = 'Please enter a conversation topic';
                errorMsg.style.display = 'block';
                return;
            }
            
            // Show loading indicator
            const loadingIndicator = document.getElementById('loadingIndicator');
            loadingIndicator.style.display = 'block';
            
            try {
                // Prepare the prompt for API
                // Removed explicit content functionality
                
                // Get character details for enhanced prompt
                const characters = storage.getCharacters();
                const char1 = characters.find(c => c.id === char1Selector.value);
                const char2 = characters.find(c => c.id === char2Selector.value);
                
                let characterDetails = '';
                
                if (char1 || char2) {
                    characterDetails += '\n\nCharacter Details:\n';
                    
                    if (char1) {
                        characterDetails += char1Name + ': ';
                        if (char1.age) characterDetails += 'Age ' + char1.age + ', ';
                        if (char1.personality) characterDetails += 'Personality: ' + char1.personality + ', ';
                        if (char1.background) characterDetails += 'Background: ' + char1.background + ', ';
                        if (char1.textingStyle) characterDetails += 'Texting style: ' + char1.textingStyle + ', ';
                        if (char1.relationship) characterDetails += 'Relationship to other character: ' + char1.relationship;
                        characterDetails = characterDetails.replace(/, $/, '') + '\n';
                    }
                    
                    if (char2) {
                        characterDetails += char2Name + ': ';
                        if (char2.age) characterDetails += 'Age ' + char2.age + ', ';
                        if (char2.personality) characterDetails += 'Personality: ' + char2.personality + ', ';
                        if (char2.background) characterDetails += 'Background: ' + char2.background + ', ';
                        if (char2.textingStyle) characterDetails += 'Texting style: ' + char2.textingStyle + ', ';
                        if (char2.relationship) characterDetails += 'Relationship to other character: ' + char2.relationship;
                        characterDetails = characterDetails.replace(/, $/, '') + '\n';
                    }
                }
                
                // Get conversation mode
                const conversationMode = document.getElementById('conversationMode').value;
                
                let prompt;
                let formatInstructions;
                
                // Check for initial messages
                const char1InitialMsg = document.getElementById('char1InitialMsg').value.trim();
                const char2InitialMsg = document.getElementById('char2InitialMsg').value.trim();
                let initialMessagesInstruction = '';
                if (char1InitialMsg || char2InitialMsg) {
                    initialMessagesInstruction = '\n\nStart the conversation with these initial messages:\n';
                    if (char1InitialMsg) {
                        initialMessagesInstruction += char1Name + ': ' + char1InitialMsg + '\n';
                    }
                    if (char2InitialMsg) {
                        initialMessagesInstruction += char2Name + ': ' + char2InitialMsg + '\n';
                    }
                    initialMessagesInstruction += 'Continue the conversation naturally from these starting messages.\n';
                }
                
                // Check for continue mode
                const chatMessages = document.getElementById('chatMessages');
                let existingConversation = '';
                if (window.continueMode && chatMessages.innerHTML.trim()) {
                    const messages = chatMessages.querySelectorAll('.message');
                    existingConversation = '\n\nContinue this existing conversation:\n';
                    messages.forEach(msg => {
                        const sender = msg.querySelector('.message-username').textContent;
                        const timestamp = msg.querySelector('.message-timestamp').textContent;
                        const content = msg.querySelector('.message-text').textContent;
                        existingConversation += `${sender} | ${timestamp} | ${content}\n`;
                    });
                    existingConversation += '\nGenerate ' + messageCount + ' more messages continuing this conversation naturally.\n';
                }
                
                // Set mode-specific prompts and format instructions
                switch(conversationMode) {
                    case 'text':
                        formatInstructions = 'Format each message as: "CHARACTER_NAME | TIMESTAMP | message content" where TIMESTAMP is in format "12:34 PM". Messages should be texting style - sometimes short, sometimes longer, with occasional typos, emojis, and casual language.';
                        if (window.continueMode && existingConversation) {
                            prompt = existingConversation;
                        } else {
                            prompt = 'Generate a text message conversation between ' + char1Name + ' and ' + char2Name + ' about ' + topic + '. ' +
                            'Create exactly ' + messageCount + ' messages total, alternating between the two characters. ' + 
                            formatInstructions + characterDetails + ' ' +
                            'Keep messages natural and conversational like real texting.' + initialMessagesInstruction;
                        }
                        break;
                    
                    case 'inperson':
                        formatInstructions = 'Format each line as: "CHARACTER_NAME | message content". Include body language, tone of voice, and setting details in brackets [like this].';
                        if (window.continueMode && existingConversation) {
                            prompt = existingConversation;
                        } else {
                            prompt = 'Generate an in-person conversation between ' + char1Name + ' and ' + char2Name + ' about ' + topic + '. ' +
                            'Create exactly ' + messageCount + ' speaking turns total, alternating between the two characters. ' +
                            formatInstructions + characterDetails + ' ' +
                            'Include physical actions, facial expressions, and environmental context.' + initialMessagesInstruction;
                        }
                        break;
                    
                    case 'phone':
                        formatInstructions = 'Format each line as: "CHARACTER_NAME | message content". Include vocal cues, pauses, and non-verbal sounds in brackets [like this].';
                        if (window.continueMode && existingConversation) {
                            prompt = existingConversation;
                        } else {
                            prompt = 'Generate a phone conversation between ' + char1Name + ' and ' + char2Name + ' about ' + topic + '. ' +
                            'Create exactly ' + messageCount + ' speaking turns total, alternating between the two characters. ' +
                            formatInstructions + characterDetails + ' ' +
                            'Include vocal tones, pauses, interruptions, and background sounds.' + initialMessagesInstruction;
                        }
                        break;
                    
                    
                    case 'social':
                        formatInstructions = 'Format each post/comment as: "CHARACTER_NAME | TIMESTAMP | message content". Include hashtags, mentions, and emoji reactions.';
                        if (window.continueMode && existingConversation) {
                            prompt = existingConversation;
                        } else {
                            prompt = 'Generate a social media conversation between ' + char1Name + ' and ' + char2Name + ' about ' + topic + '. ' +
                            'Create exactly ' + messageCount + ' posts/comments total, alternating between the two users. ' +
                            formatInstructions + characterDetails + ' ' +
                            'Include likes, reactions, hashtags, and casual social media language.' + initialMessagesInstruction;
                        }
                        break;
                    
                    default:
                        formatInstructions = 'Format each message as: "CHARACTER_NAME | TIMESTAMP | message content" where TIMESTAMP is in format "12:34 PM".';
                        if (window.continueMode && existingConversation) {
                            prompt = existingConversation;
                        } else {
                            prompt = 'Generate a conversation between ' + char1Name + ' and ' + char2Name + ' about ' + topic + '. ' +
                            'Create exactly ' + messageCount + ' messages total, alternating between the two characters. ' +
                            formatInstructions + characterDetails + initialMessagesInstruction;
                        }
                }
                
                // Determine API endpoint
                let apiEndpoint = document.getElementById('apiEndpoint').value;
                if (apiEndpoint === 'custom') {
                    apiEndpoint = document.getElementById('customEndpoint').value;
                    if (!apiEndpoint) {
                        throw new Error('Please enter a custom API endpoint URL');
                    }
                }
                
                // Get model name
                const modelSelect = document.getElementById('model');
                const customModelField = document.getElementById('customModel');
                const model = modelSelect.value === 'custom' ? customModelField.value : modelSelect.value;
                
                // Get system prompt (advanced mode)
                const advancedMode = document.getElementById('advancedMode').checked;
                let defaultSystemPrompt;
                
                // Set mode-specific default system prompts
                switch(conversationMode) {
                    case 'text':
                        defaultSystemPrompt = 'You are an AI that generates realistic text message conversations between two characters. Create natural, casual, and authentic conversations like real text messages. Use any provided character details to influence their personality, communication style, and relationship dynamic. Keep all content appropriate and respectful.';
                        break;
                    case 'inperson':
                        defaultSystemPrompt = 'You are an AI that generates realistic in-person conversations between two characters. Include body language, facial expressions, tone of voice, and environmental context. Create natural dialogue with realistic interactions and physical cues.';
                        break;
                    case 'phone':
                        defaultSystemPrompt = 'You are an AI that generates realistic phone conversations between two characters. Include vocal tones, pauses, interruptions, and background sounds. Create natural phone dialogue with realistic audio cues and conversational patterns.';
                        break;
                    case 'social':
                        defaultSystemPrompt = 'You are an AI that generates realistic social media conversations between two characters. Include hashtags, mentions, likes, reactions, and emojis. Create casual social media interactions typical of platforms like Twitter, Facebook, or Instagram.';
                        break;
                    default:
                        defaultSystemPrompt = 'You are an AI that generates realistic conversations between two characters. Create natural, authentic dialogue that fits the specified format and context.';
                }
                
                
                if (!model) {
                    throw new Error('Please select a model');
                }
                
                // Display API request info
                console.log('Sending request to: ' + apiEndpoint);
                console.log('Using model: ' + model);
                if (advancedMode && document.getElementById('systemPrompt').value.trim()) {
                    if (document.getElementById('replaceEntirePrompt').checked) {
                        console.log('Using exact replacement message from Advanced Mode');
                    } else {
                        console.log('Combining custom message with automatic prompts');
                    }
                } else {
                    console.log('Using automatic prompt generation');
                }
                
                // Use local fallback if test mode is enabled
                if (document.getElementById('apiEndpoint').value === 'test-mode') {
                    console.log("Using demo mode with local fallback data");
                    setTimeout(() => {
                        const mockConversation = generateMockConversation(char1Name, char2Name, topic, messageCount, conversationMode);
                        displayConversation(mockConversation, char1Name, char2Name, window.continueMode);
                        loadingIndicator.style.display = 'none';
                    }, 1500);
                    return;
                }
                
                // Call Grok API
                try {
                    // Get character names from input fields or selectors
                    const char1NameInput = document.getElementById('char1Name');
                    const char2NameInput = document.getElementById('char2Name');
                    const char1Name = char1NameInput.value || document.getElementById('char1Selector').options[document.getElementById('char1Selector').selectedIndex].text || 'Character 1';
                    const char2Name = char2NameInput.value || document.getElementById('char2Selector').options[document.getElementById('char2Selector').selectedIndex].text || 'Character 2';
                    
                    let requestBody;
                    const replaceEntirePrompt = document.getElementById('replaceEntirePrompt').checked;
                    const customUserMessage = document.getElementById('systemPrompt').value.trim();
                    
                    // Check if we should replace the entire prompt
                    if (advancedMode && customUserMessage && replaceEntirePrompt) {
                        // Replace entire API message with custom message
                        requestBody = {
                            model: model,
                            messages: [
                                {
                                    role: 'user',
                                    content: customUserMessage
                                }
                            ],
                            temperature: 0.7,
                            max_tokens: 4000
                        };
                    } else {
                        // Use default payload structure
                        let userPrompt = prompt;
                        
                        // If there's a custom message and we're not replacing the entire prompt,
                        // combine it with the automatic prompt
                        if (advancedMode && customUserMessage && !replaceEntirePrompt) {
                            userPrompt = customUserMessage + '\n\n' + prompt;
                        }
                        
                        requestBody = {
                            model: model,
                            messages: [
                                {
                                    role: 'system',
                                    content: defaultSystemPrompt
                                },
                                {
                                    role: 'user',
                                    content: userPrompt
                                }
                            ],
                            temperature: 0.7,
                            max_tokens: 4000
                        };
                    }
                    
                    const response = await fetch(apiEndpoint, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(requestBody)
                    });
                    
                    if (!response.ok) {
                        const errorText = await response.text();
                        console.error("API Response:", errorText);
                        throw new Error('API request failed with status: ' + response.status + '. Check your API key and endpoint.');
                    }
                    
                    const data = await response.json();
                    const generatedConversation = data.choices[0].message.content;
                    
                    // Process the generated conversation
                    displayConversation(generatedConversation, char1Name, char2Name, window.continueMode);
                } catch (error) {
                    // Handle network errors specifically
                    if (error.message === 'Failed to fetch' || error.name === 'TypeError') {
                        throw new Error('Network error when connecting to ' + apiEndpoint + '. This could be due to CORS restrictions, an invalid domain, or the API being down.');
                    } else {
                        throw error; // Re-throw other errors
                    }
                }
                
            } catch (error) {
                console.error('Error:', error);
                errorMsg.textContent = 'Error: ' + (error.message || 'Failed to generate conversation');
                errorMsg.style.display = 'block';
            } finally {
                loadingIndicator.style.display = 'none';
                window.continueMode = false; // Reset continue mode
            }
        });
        
        // Continue conversation button handler
        document.getElementById('continueBtn').addEventListener('click', async function() {
            // Check if there's an existing conversation to continue
            const chatMessages = document.getElementById('chatMessages');
            if (!chatMessages.innerHTML.trim()) {
                alert('No existing conversation to continue. Please generate a conversation first.');
                return;
            }
            
            // Enable continue mode and trigger the generate button
            window.continueMode = true;
            document.getElementById('generateBtn').click();
        });
        
        // Autofill prompt button handler
        document.getElementById('autofillPromptBtn').addEventListener('click', function() {
            const conversationMode = document.getElementById('conversationMode').value;
            const char1Name = document.getElementById('char1Name').value || 'Character 1';
            const char2Name = document.getElementById('char2Name').value || 'Character 2';
            const topic = document.getElementById('topic').value || 'a topic of your choice';
            const messageCount = document.getElementById('messageCount').value || '10';
            
            // Get character details if available
            const char1PersonalityText = document.querySelector('#char1Personality .personality-summary')?.textContent || '';
            const char2PersonalityText = document.querySelector('#char2Personality .personality-summary')?.textContent || '';
            
            let characterDetails = '';
            if (char1PersonalityText) {
                characterDetails += '\n\n' + char1Name + ': ' + char1PersonalityText;
            }
            if (char2PersonalityText) {
                characterDetails += '\n' + char2Name + ': ' + char2PersonalityText;
            }
            
            let formatInstructions;
            let prompt;
            
            // Build the default prompt based on conversation mode
            switch(conversationMode) {
                case 'text':
                    formatInstructions = 'Format each message as: "CHARACTER_NAME | TIMESTAMP | message content" where TIMESTAMP is in format "12:34 PM". Messages should be texting style - sometimes short, sometimes longer, with occasional typos, emojis, and casual language.';
                    prompt = 'Generate a text message conversation between ' + char1Name + ' and ' + char2Name + ' about ' + topic + '. ' +
                    'Create exactly ' + messageCount + ' messages total, alternating between the two characters. ' + 
                    formatInstructions + characterDetails + ' ' +
                    'Keep messages natural and conversational like real texting.';
                    break;
                    
                case 'inperson':
                    formatInstructions = 'Format each line as: "CHARACTER_NAME | message content". Include body language, tone of voice, and setting details in brackets [like this].';
                    prompt = 'Generate an in-person conversation between ' + char1Name + ' and ' + char2Name + ' about ' + topic + '. ' +
                    'Create exactly ' + messageCount + ' speaking turns total, alternating between the two characters. ' +
                    formatInstructions + characterDetails + ' ' +
                    'Include physical actions, facial expressions, and environmental context.';
                    break;
                    
                case 'phone':
                    formatInstructions = 'Format each line as: "CHARACTER_NAME | message content". Include vocal cues, pauses, and non-verbal sounds in brackets [like this].';
                    prompt = 'Generate a phone conversation between ' + char1Name + ' and ' + char2Name + ' about ' + topic + '. ' +
                    'Create exactly ' + messageCount + ' speaking turns total, alternating between the two characters. ' +
                    formatInstructions + characterDetails + ' ' +
                    'Include vocal tones, pauses, interruptions, and background sounds.';
                    break;
                    
                case 'social':
                    formatInstructions = 'Format each post/comment as: "CHARACTER_NAME | TIMESTAMP | message content". Include hashtags, mentions, and emoji reactions.';
                    prompt = 'Generate a social media conversation between ' + char1Name + ' and ' + char2Name + ' about ' + topic + '. ' +
                    'Create exactly ' + messageCount + ' posts/comments total, alternating between the two users. ' +
                    formatInstructions + characterDetails + ' ' +
                    'Include likes, reactions, hashtags, and casual social media language.';
                    break;
                    
                default:
                    formatInstructions = 'Format each message as: "CHARACTER_NAME | TIMESTAMP | message content" where TIMESTAMP is in format "12:34 PM".';
                    prompt = 'Generate a conversation between ' + char1Name + ' and ' + char2Name + ' about ' + topic + '. ' +
                    'Create exactly ' + messageCount + ' messages total, alternating between the two characters. ' +
                    formatInstructions + characterDetails;
            }
            
            // Set the prompt in the text area
            document.getElementById('systemPrompt').value = prompt;
        });
        
        // Function to display conversation in the UI
        function displayConversation(conversationText, char1Name, char2Name, appendMode = false) {
            const conversationMode = document.getElementById('conversationMode').value;
            
            // Process the generated conversation - all modes will be parsed to extract clean content
            const messages = conversationText.split('\n')
                .filter(line => line.trim().length > 0)
                .map(line => {
                    let match;
                    
                    // Different regex patterns for different modes
                    switch(conversationMode) {
                        case 'inperson':
                        case 'phone':
                            // Format: CHARACTER_NAME | message content
                            match = line.match(/^(.+?)\s*\|\s*(.+)$/);
                            if (match) {
                                // Keep the full content with brackets for display
                                const time = new Date();
                                time.setHours(10 + Math.floor(Math.random() * 12));
                                time.setMinutes(Math.floor(Math.random() * 60));
                                const timestamp = time.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
                                
                                return {
                                    character: match[1].trim(),
                                    timestamp: timestamp,
                                    content: match[2].trim()
                                };
                            }
                            break;
                        
                        
                        case 'text':
                        case 'social':
                        default:
                            // Format: CHARACTER_NAME | TIMESTAMP | message content
                            match = line.match(/^(.+?)\s*\|\s*(.+?)\s*\|\s*(.+)$/);
                            if (match) {
                                // For social media, remove hashtags and mentions from display
                                let content = match[3].trim();
                                if (conversationMode === 'social') {
                                    // Keep the content as-is for social media, but could strip if needed
                                    content = content;
                                }
                                
                                return {
                                    character: match[1].trim(),
                                    timestamp: match[2].trim(),
                                    content: content
                                };
                            }
                            break;
                    }
                    
                    return null;
                })
                .filter(Boolean);
            
            // Clear previous messages only if not in append mode
            const chatMessages = document.getElementById('chatMessages');
            if (!appendMode) {
                chatMessages.textContent = '';
            }
            
            messages.forEach((msg, index) => {
                const isChar1 = msg.character.toLowerCase().includes(char1Name.toLowerCase());
                const charName = isChar1 ? char1Name : char2Name;
                const charPreviewId = isChar1 ? 'char1Preview' : 'char2Preview';
                
                // Get avatar from preview if available
                const avatarPreview = document.getElementById(charPreviewId);
                let avatarSrc = '/api/placeholder/40/40';
                
                // Safely get avatar source with validation
                if (avatarPreview.querySelector('img')) {
                    const previewSrc = avatarPreview.querySelector('img').src;
                    avatarSrc = securityUtils.sanitizeUrl(previewSrc, '/api/placeholder/40/40');
                }
                
                // Use the timestamp from the AI response
                const displayTimestamp = 'Today at ' + msg.timestamp;
                
                // Create message element - all modes display the same way
                const messageElement = document.createElement('div');
                messageElement.className = 'message';
                
                const avatar = document.createElement('div');
                avatar.className = 'message-avatar';
                
                const img = document.createElement('img');
                img.src = avatarSrc;
                img.alt = charName;
                img.style.width = '100%';
                img.style.height = '100%';
                img.style.objectFit = 'cover';
                avatar.appendChild(img);
                
                const messageContent = document.createElement('div');
                messageContent.className = 'message-content';
                
                const messageHeader = document.createElement('div');
                messageHeader.className = 'message-header';
                
                const username = document.createElement('div');
                username.className = 'message-username';
                username.textContent = charName;
                
                const timestamp = document.createElement('div');
                timestamp.className = 'message-timestamp';
                timestamp.textContent = displayTimestamp;
                
                const messageText = document.createElement('div');
                messageText.className = 'message-text';
                messageText.textContent = msg.content;
                
                messageHeader.appendChild(username);
                messageHeader.appendChild(timestamp);
                messageContent.appendChild(messageHeader);
                messageContent.appendChild(messageText);
                
                messageElement.appendChild(avatar);
                messageElement.appendChild(messageContent);
                
                chatMessages.appendChild(messageElement);
            });
        }
        
        // Generate mock conversation for testing with enhanced examples
        function generateMockConversation(char1Name, char2Name, topic, count, mode = 'text') {
            // Function to safely create message strings based on mode
            function createMessage(name, time, content, mode) {
                switch(mode) {
                    case 'inperson':
                    case 'phone':
                        return name + ' | ' + content;
                    case 'social':
                        return name + ' | ' + time + ' | ' + content;
                    case 'text':
                    default:
                        return name + ' | ' + time + ' | ' + content;
                }
            }
            
            // Mode-specific conversation templates
            let conversationTemplates = {};
            
            switch(mode) {
                case 'inperson':
                    conversationTemplates = {
                        "work": [
                            createMessage(char1Name, null, 'Hey, did you see the email about the new project deadline? [leaning against the doorframe]', mode),
                            createMessage(char2Name, null, '[looking up from computer] Yeah, it\'s pretty tight. We\'ll need to prioritize. [sighs]', mode),
                            createMessage(char1Name, null, '[nodding] Agreed. Should we grab a coffee and discuss? [gesturing towards the break room]', mode),
                            createMessage(char2Name, null, '[standing up and stretching] Good idea! I need a break anyway. [grabs mug]', mode),
                            createMessage(char1Name, null, 'Great, I\'ll meet you there in 5. [smiling]', mode),
                            createMessage(char2Name, null, '[walking towards door] Perfect. I\'ll bring my notes.', mode)
                        ]
                    };
                    break;
                    
                case 'phone':
                    conversationTemplates = {
                        "work": [
                            createMessage(char1Name, null, 'Hey, can you hear me? [slight static]', mode),
                            createMessage(char2Name, null, '[clearing throat] Yeah, loud and clear. About that project deadline...', mode),
                            createMessage(char1Name, null, '[papers rustling] Right, it\'s pretty tight. We need to prioritize.', mode),
                            createMessage(char2Name, null, '[typing sounds] Agreed. Hold on... [pause] Sorry, just pulling up the timeline.', mode),
                            createMessage(char1Name, null, 'No worries. [dog barking in background] Excuse my dog...', mode),
                            createMessage(char2Name, null, '[laughing] No problem! So, what if we focus on the core features first?', mode)
                        ]
                    };
                    break;
                    
                    
                case 'social':
                    conversationTemplates = {
                        "work": [
                            createMessage(char1Name, '9:15 AM', 'Anyone else see that crazy project deadline? 😅 #WorkLife #CoffeePlease', mode),
                            createMessage(char2Name, '9:18 AM', '@' + char1Name.toLowerCase().replace(/\s+/g, '') + ' Tell me about it! Time to prioritize like crazy 💪 #TeamWork', mode),
                            createMessage(char1Name, '9:22 AM', '@' + char2Name.toLowerCase().replace(/\s+/g, '') + ' Coffee break to strategize? ☕️ #ProductivityHack', mode),
                            createMessage(char2Name, '9:25 AM', 'YES PLEASE! 🙌 Meet you at the usual spot in 10? #CoffeeTime', mode),
                            createMessage(char1Name, '9:27 AM', 'On my way! Bringing my laptop 💻 #WorkFromCafe', mode),
                            createMessage(char2Name, '9:30 AM', 'Same! Let\'s crush this deadline 🚀 #MondayMotivation', mode)
                        ]
                    };
                    break;
                    
                case 'text':
                default:
                    conversationTemplates = {
                        "work": [
                            createMessage(char1Name, '9:15 AM', 'Hey, did you see the email about the new project deadline?', mode),
                            createMessage(char2Name, '9:18 AM', 'Yeah, it\'s pretty tight. We\'ll need to prioritize the main features first', mode),
                            createMessage(char1Name, '9:22 AM', 'Agreed. Should we schedule a quick call to discuss?', mode),
                            createMessage(char2Name, '9:25 AM', 'Good idea! How about 2pm today?', mode),
                            createMessage(char1Name, '9:27 AM', 'Perfect, I\'ll send the calendar invite', mode),
                            createMessage(char2Name, '9:30 AM', 'Thanks! I\'ll prep some notes beforehand', mode)
                        ],
                        "friendship": [
                            createMessage(char1Name, '7:30 PM', 'What are you up to tonight?', mode),
                            createMessage(char2Name, '7:33 PM', 'Just watching Netflix lol. You?', mode),
                            createMessage(char1Name, '7:35 PM', 'Same! Have you seen that new series everyone\'s talking about?', mode),
                            createMessage(char2Name, '7:38 PM', 'Which one? There are like 5 new shows this week 😅', mode),
                            createMessage(char1Name, '7:40 PM', 'The sci-fi one with the time travel plot', mode),
                            createMessage(char2Name, '7:42 PM', 'Oh that one! Yeah it\'s actually really good. Want to watch together?', mode)
                        ],
                        "family": [
                            createMessage(char1Name, '6:45 PM', 'Dinner\'s ready! Come downstairs', mode),
                            createMessage(char2Name, '6:48 PM', 'Coming! Just finishing up this assignment', mode),
                            createMessage(char1Name, '6:50 PM', 'Okay but don\'t let it get cold', mode),
                            createMessage(char2Name, '6:52 PM', 'I\'ll be down in 2 minutes, promise', mode),
                            createMessage(char1Name, '6:55 PM', 'Alright, I\'ll keep your plate warm', mode),
                            createMessage(char2Name, '6:57 PM', 'You\'re the best, thanks!', mode)
                        ]
                    };
                    break;
            }
            
            // Try to find a template that matches the topic
            let conversation = "";
            const topicLower = topic.toLowerCase();
            
            if (topicLower.includes('work') || topicLower.includes('job') || topicLower.includes('project')) {
                return conversationTemplates.work.slice(0, Math.min(count, 6)).join('\n');
            } else if (topicLower.includes('friend') || topicLower.includes('hang') || topicLower.includes('movie')) {
                return conversationTemplates.friendship.slice(0, Math.min(count, 6)).join('\n');
            } else if (topicLower.includes('family') || topicLower.includes('dinner') || topicLower.includes('home')) {
                return conversationTemplates.family.slice(0, Math.min(count, 6)).join('\n');
            }
            
            // Fallback to original generation method - mode-specific
            let templates, responses;
            
            switch(mode) {
                case 'inperson':
                    templates = [
                        "[walking over] Hey, what do you think about {topic}? [curious expression]",
                        "[leaning back in chair] I've been thinking about {topic} lately. It's interesting!",
                        "[excited] Have you heard the latest about {topic}?",
                        "[frowning slightly] I'm not sure how I feel about {topic}, to be honest.",
                        "[animated gestures] Let me tell you what happened with {topic} yesterday!",
                        "[thoughtful] Do you want to discuss {topic} more?"
                    ];
                    responses = [
                        "[eyes widening] Oh really? Tell me more!",
                        "[nodding] That's interesting. I've been wondering about that too.",
                        "[shocked] No way! What happened?",
                        "[surprised] I had no idea about that!",
                        "[knowingly] Yeah, I've been following that for a while.",
                        "[concerned] That's crazy! What do you think about it?"
                    ];
                    break;
                    
                case 'phone':
                    templates = [
                        "Hey, can you hear me? I wanted to talk about {topic}. [slight echo]",
                        "[clearing throat] I've been thinking about {topic} lately.",
                        "[excited voice] Have you heard the latest about {topic}?",
                        "[pausing] I'm not sure how I feel about {topic}, to be honest.",
                        "[voice getting animated] Let me tell you what happened with {topic}!",
                        "[static briefly] Do you want to discuss {topic} more?"
                    ];
                    responses = [
                        "[voice raising] Oh really? Tell me more!",
                        "[phone shuffling] That's interesting. I've been wondering about that too.",
                        "[loud] No way! What happened?",
                        "[surprised tone] I had no idea about that!",
                        "[calmly] Yeah, I've been following that for a while.",
                        "[concerned voice] That's crazy! What do you think?"
                    ];
                    break;
                    
                    
                case 'social':
                    templates = [
                        "Anyone else thinking about {topic}? \ud83e\udd14 #Thoughts #Discussion",
                        "Been pondering {topic} lately... Interesting stuff! \ud83d\udca1 #DeepThoughts",
                        "OMG have you all heard about {topic}?? \ud83d\ude31 #BreakingNews",
                        "Not sure how I feel about {topic} tbh... \ud83d\ude15 #Conflicted",
                        "You guys won't believe what happened with {topic}! Thread below \ud83d\udc47",
                        "Who wants to discuss {topic}? Drop your thoughts! \ud83d\udcac #OpenDiscussion"
                    ];
                    responses = [
                        "@user OMG yes! Tell me more! \ud83d\ude2e",
                        "@user So true! I've been wondering about this too \ud83d\udc4d",
                        "@user NO WAY! What happened?? \ud83d\ude31",
                        "@user Wait what?? I had no idea! \ud83d\ude35",
                        "@user Been following this! Wild times \ud83d\ude05",
                        "@user This is crazy! What's your take? \ud83e\udd2f"
                    ];
                    break;
                    
                default:
                    templates = [
                        "Hey, what do you think about {topic}?",
                        "I've been thinking about {topic} lately. It's interesting!",
                        "Have you heard the latest about {topic}?",
                        "I'm not sure how I feel about {topic}, to be honest.",
                        "Let me tell you what happened with {topic} yesterday!",
                        "Do you want to discuss {topic} more?",
                        "I can't believe what's going on with {topic}!",
                        "What's your take on {topic}?",
                        "I read an article about {topic} the other day.",
                        "My friend was just telling me about {topic}."
                    ];
                    responses = [
                        "Oh really? Tell me more!",
                        "That's interesting. I've been wondering about that too.",
                        "No way! What happened?",
                        "I had no idea about that!",
                        "Yeah, I've been following that for a while.",
                        "That's crazy! What do you think about it?",
                        "I'm not surprised, to be honest.",
                        "Wow, that's news to me!",
                        "I've been thinking the same thing!",
                        "Let's talk more about this later."
                    ];
            }
            
            let currentHour = 10; // Start at 10 AM
            let currentMinute = 0;
            
            for (let i = 0; i < count; i++) {
                const isFirst = i % 2 === 0;
                const name = isFirst ? char1Name : char2Name;
                
                // Generate realistic timestamps (progress 1-5 minutes between messages)
                currentMinute += Math.floor(Math.random() * 5) + 1;
                if (currentMinute >= 60) {
                    currentHour++;
                    currentMinute = currentMinute - 60;
                }
                
                const displayHour = currentHour > 12 ? currentHour - 12 : (currentHour === 0 ? 12 : currentHour);
                const ampm = currentHour >= 12 ? 'PM' : 'AM';
                const timestamp = displayHour + ':' + String(currentMinute).padStart(2, '0') + ' ' + ampm;
                
                let message;
                if (isFirst) {
                    // Template with topic
                    let template = templates[Math.floor(Math.random() * templates.length)];
                    message = template.replace("{topic}", topic);
                } else {
                    // Response
                    message = responses[Math.floor(Math.random() * responses.length)];
                }
                
                conversation += createMessage(name, timestamp, message, mode) + '\n';
            }
            
            return conversation;
        }
        
        // Export functions
        function generateChatOnlyHTML() {
            const chatMessages = document.getElementById('chatMessages');
            const char1Name = document.getElementById('char1Name').value || 'Character 1';
            const char2Name = document.getElementById('char2Name').value || 'Character 2';
            const topic = document.getElementById('topic').value || 'Conversation';
            
            // Get character details if available
            const characters = storage.getCharacters();
            const char1Selector = document.getElementById('char1Selector');
            const char2Selector = document.getElementById('char2Selector');
            const char1 = characters.find(c => c.id === char1Selector.value);
            const char2 = characters.find(c => c.id === char2Selector.value);
            
            // Create a new document to safely generate HTML
            const parser = new DOMParser();
            
            // Create a basic HTML structure
            const baseHtml = `
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <title>AI Dialogue Generator Chat</title>
                <style>
                    /* CSS styles here - unchanged */
                    body { 
                        font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
                        background: linear-gradient(135deg, #23272a 0%, #2c2f33 100%);
                        color: #dcddde;
                        line-height: 1.5;
                        min-height: 100vh;
                        padding: 20px;
                    }
                    
                    .container {
                        max-width: 800px;
                        margin: 0 auto;
                        background: #2f3136;
                        border-radius: 16px;
                        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
                        overflow: hidden;
                        backdrop-filter: blur(10px);
                        border: 1px solid #4f545c;
                    }
                    
                    .chat-header {
                        background: linear-gradient(135deg, #5865f2 0%, #4752c4 100%);
                        padding: 24px 32px;
                        text-align: center;
                        position: relative;
                        overflow: hidden;
                    }
                    
                    .chat-title {
                        color: white;
                        font-size: 28px;
                        font-weight: 700;
                        margin-bottom: 8px;
                        text-shadow: 0 2px 4px rgba(0,0,0,0.3);
                    }
                    
                    .chat-subtitle {
                        color: rgba(255,255,255,0.9);
                        font-size: 16px;
                    }
                    
                    .chat-participants {
                        display: flex;
                        justify-content: center;
                        gap: 32px;
                        margin-top: 20px;
                    }
                    
                    .participant {
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        gap: 12px;
                    }
                    
                    .participant-avatar {
                        width: 64px;
                        height: 64px;
                        border-radius: 50%;
                        border: 3px solid rgba(255,255,255,0.3);
                        overflow: hidden;
                        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                    }
                    
                    .participant-avatar img {
                        width: 100%;
                        height: 100%;
                        object-fit: cover;
                    }
                    
                    .participant-name {
                        color: white;
                        font-weight: 600;
                        font-size: 14px;
                        text-shadow: 0 1px 2px rgba(0,0,0,0.3);
                    }
                    
                    .chat-messages {
                        padding: 32px;
                    }
                    
                    .message {
                        display: flex;
                        margin-bottom: 24px;
                        padding: 16px 20px;
                        border-radius: 12px;
                    }
                    
                    .message-avatar {
                        width: 48px;
                        height: 48px;
                        border-radius: 50%;
                        margin-right: 16px;
                        overflow: hidden;
                    }
                    
                    .message-avatar img {
                        width: 100%;
                        height: 100%;
                        object-fit: cover;
                    }
                    
                    .message-username {
                        font-weight: 600;
                        font-size: 16px;
                        margin-bottom: 6px;
                    }
                    
                    .message-timestamp {
                        color: #72767d;
                        font-size: 12px;
                        font-weight: 500;
                    }
                    
                    .message-text {
                        color: #dcddde;
                        font-size: 15px;
                        line-height: 1.6;
                        margin-top: 2px;
                    }
                    
                    .chat-footer {
                        padding: 20px;
                        text-align: center;
                        border-top: 1px solid #4f545c;
                        font-size: 12px;
                        color: #72767d;
                    }
                
                .progress-bar {
                    width: 100%;
                    height: 8px;
                    background-color: #2f3136;
                    border-radius: 4px;
                    overflow: hidden;
                    margin: 12px 0;
                }
                
                .progress-fill {
                    height: 100%;
                    background: linear-gradient(90deg, #5865f2 0%, #7289da 100%);
                    width: 0%;
                    transition: width 0.3s ease;
                }
                
                .primary-btn {
                    background: linear-gradient(135deg, #5865f2 0%, #7289da 100%);
                    color: white;
                    font-weight: 600;
                }
                
                .primary-btn:hover {
                    background: linear-gradient(135deg, #4752c4 0%, #6879d9 100%);
                }
                </style>
            </head>
            <body>
                <div class="container">
                    <div class="chat-header">
                        <h1 class="chat-title"></h1>
                        <p class="chat-subtitle"></p>
                        <div class="chat-participants">
                            <div class="participant">
                                <div class="participant-avatar">
                                    <img>
                                </div>
                                <div class="participant-name"></div>
                            </div>
                            <div class="participant">
                                <div class="participant-avatar">
                                    <img>
                                </div>
                                <div class="participant-name"></div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="chat-messages">
                    </div>
                    
                    <div class="chat-footer">
                        <div></div>
                        <div class="export-info">Created with AI Dialogue Generator • Made with Claude AI</div>
                    </div>
                </div>
            </body>
            </html>
            `;
            
            // Now use DOM methods to safely set content
            const doc = parser.parseFromString(baseHtml, 'text/html');
            // Set document title safely
            doc.title = char1Name + ' & ' + char2Name + ' - ' + topic;
            doc.querySelector('.chat-title').textContent = char1Name + ' & ' + char2Name;
            doc.querySelector('.chat-subtitle').textContent = 'Conversation about ' + topic;
            
            // Character 1 info
            const char1Avatar = doc.querySelector('.participant:first-of-type img');
            char1Avatar.src = char1 ? (char1.avatar || '/api/placeholder/64/64') : '/api/placeholder/64/64';
            char1Avatar.alt = char1Name;
            doc.querySelector('.participant:first-of-type .participant-name').textContent = char1Name;
            
            // Character 2 info
            const char2Avatar = doc.querySelector('.participant:last-of-type img');
            char2Avatar.src = char2 ? (char2.avatar || '/api/placeholder/64/64') : '/api/placeholder/64/64';
            char2Avatar.alt = char2Name;
            doc.querySelector('.participant:last-of-type .participant-name').textContent = char2Name;
            
            // Clone messages from the current page to the new document
            const chatMessagesContainer = doc.querySelector('.chat-messages');
            const conversationMode = document.getElementById('conversationMode').value;
            
            Array.from(chatMessages.children).forEach(message => {
                const clonedMessage = message.cloneNode(true);
                
                // Clean up the message text for export
                const messageTextElement = clonedMessage.querySelector('.message-text');
                if (messageTextElement) {
                    let cleanText = messageTextElement.textContent;
                    
                    // Remove bracketed content for in-person and phone modes
                    if (conversationMode === 'inperson' || conversationMode === 'phone') {
                        cleanText = cleanText.replace(/\[.*?\]/g, '').trim();
                    }
                    
                    messageTextElement.textContent = cleanText;
                }
                
                chatMessagesContainer.appendChild(clonedMessage);
            });
            
            // Set the footer timestamp
            doc.querySelector('.chat-footer div:first-of-type').textContent = 
                `Generated on ${new Date().toLocaleDateString()} at ${new Date().toLocaleTimeString()}`;
            
            // Return the HTML as a string
            return new XMLSerializer().serializeToString(doc);
        }
        
        // Download Full HTML
        document.getElementById('downloadFullBtn').addEventListener('click', function() {
            const htmlContent = document.documentElement.outerHTML;
            const blob = new Blob([htmlContent], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'dialogue-generator.html';
            document.body.appendChild(a);
            a.click();
            
            // Clean up
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 0);
        });
        
        // Download Chat Only
        document.getElementById('downloadChatOnlyBtn').addEventListener('click', function() {
            const chatOnlyHTML = generateChatOnlyHTML();
            const blob = new Blob([chatOnlyHTML], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            
            const char1Name = document.getElementById('char1Name').value || 'Character1';
            const char2Name = document.getElementById('char2Name').value || 'Character2';
            const topic = document.getElementById('topic').value || 'Chat';
            
            // Create a clean filename
            const sanitizedChar1 = char1Name.replace(/[^a-zA-Z0-9_-]/g, '_');
            const sanitizedChar2 = char2Name.replace(/[^a-zA-Z0-9_-]/g, '_');
            const sanitizedTopic = topic.replace(/[^a-zA-Z0-9_-]/g, '_');
            const filename = sanitizedChar1 + '_' + sanitizedChar2 + '_' + sanitizedTopic + '_chat.html';
            
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            
            // Clean up
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 0);
        });
        
        // Voice generation functionality
        const voiceGeneration = {
            elevenLabsApiKey: null,
            isEnabled: false,
            
            init: function() {
                // Load saved settings
                const savedSettings = localStorage.getItem('voiceSettings');
                if (savedSettings) {
                    const settings = JSON.parse(savedSettings);
                    this.elevenLabsApiKey = settings.elevenLabsApiKey;
                    this.isEnabled = settings.isEnabled;
                    
                    document.getElementById('elevenLabsApiKey').value = this.elevenLabsApiKey || '';
                    document.getElementById('enableVoiceGeneration').checked = this.isEnabled;
                }
                
                // Update UI visibility
                this.updateUIVisibility();
                
                // Add event listeners
                document.getElementById('enableVoiceGeneration').addEventListener('change', (e) => {
                    this.isEnabled = e.target.checked;
                    this.saveSettings();
                    this.updateUIVisibility();
                });
                
                document.getElementById('elevenLabsApiKey').addEventListener('change', (e) => {
                    this.elevenLabsApiKey = e.target.value;
                    this.saveSettings();
                });
                
                document.getElementById('testVoiceApiBtn').addEventListener('click', () => {
                    this.testVoiceApi();
                });
                
                document.getElementById('generateAudioBtn').addEventListener('click', () => {
                    this.generateAudio();
                });
                
                // Update character labels when selections change
                document.getElementById('char1Selector').addEventListener('change', () => {
                    this.updateCharacterLabels();
                });
                
                document.getElementById('char2Selector').addEventListener('change', () => {
                    this.updateCharacterLabels();
                });
            },
            
            saveSettings: function() {
                const settings = {
                    elevenLabsApiKey: this.elevenLabsApiKey,
                    isEnabled: this.isEnabled
                };
                localStorage.setItem('voiceSettings', JSON.stringify(settings));
            },
            
            updateUIVisibility: function() {
                const voiceSettings = document.getElementById('voiceSettings');
                const voiceGenerationSection = document.getElementById('voiceGenerationSection');
                
                if (this.isEnabled) {
                    voiceSettings.style.display = 'block';
                    if (this.elevenLabsApiKey) {
                        voiceGenerationSection.style.display = 'block';
                        this.updateCharacterLabels();
                    }
                } else {
                    voiceSettings.style.display = 'none';
                    voiceGenerationSection.style.display = 'none';
                }
            },
            
            updateCharacterLabels: function() {
                const char1 = storage.getCharacterById(document.getElementById('char1Selector').value);
                const char2 = storage.getCharacterById(document.getElementById('char2Selector').value);
                
                const char1Label = document.getElementById('char1VoiceLabel');
                const char2Label = document.getElementById('char2VoiceLabel');
                
                if (char1) {
                    char1Label.textContent = char1.name + ':';
                } else {
                    char1Label.textContent = 'Character 1:';
                }
                
                if (char2) {
                    char2Label.textContent = char2.name + ':';
                } else {
                    char2Label.textContent = 'Character 2:';
                }
            },
            
            testVoiceApi: async function() {
                const apiKey = document.getElementById('elevenLabsApiKey').value;
                const errorMsg = document.getElementById('voiceApiErrorMsg');
                const successMsg = document.getElementById('voiceApiSuccessMsg');
                
                errorMsg.style.display = 'none';
                successMsg.style.display = 'none';
                
                if (!apiKey) {
                    errorMsg.textContent = 'Please enter an API key';
                    errorMsg.style.display = 'block';
                    return;
                }
                
                try {
                    const response = await fetch('https://api.elevenlabs.io/v1/voices', {
                        headers: {
                            'xi-api-key': apiKey
                        }
                    });
                    
                    if (response.ok) {
                        successMsg.style.display = 'block';
                        this.elevenLabsApiKey = apiKey;
                        this.saveSettings();
                        this.updateUIVisibility();
                        setTimeout(() => {
                            successMsg.style.display = 'none';
                        }, 3000);
                    } else {
                        throw new Error('Invalid API key');
                    }
                } catch (error) {
                    errorMsg.textContent = 'Failed to connect to ElevenLabs API: ' + error.message;
                    errorMsg.style.display = 'block';
                }
            },
            
            getMessages: function() {
                const messageElements = document.querySelectorAll('.message');
                const messages = [];
                
                messageElements.forEach(msg => {
                    const username = msg.querySelector('.message-username').textContent;
                    const content = msg.querySelector('.message-text').textContent;
                    messages.push({ username, content });
                });
                
                return messages;
            },
            
            preprocessTextForSpeech: function(text) {
                // Remove markdown formatting
                text = text.replace(/\*\*([^*]+)\*\*/g, '$1'); // Bold
                text = text.replace(/\*([^*]+)\*/g, '$1'); // Italic
                text = text.replace(/__([^_]+)__/g, '$1'); // Underline
                text = text.replace(/~~([^~]+)~~/g, '$1'); // Strikethrough
                text = text.replace(/`([^`]+)`/g, '$1'); // Code
                
                // Remove actions in asterisks, parentheses, or brackets
                text = text.replace(/\*[^*]+\*/g, ''); // *actions*
                text = text.replace(/\([^)]*\)/g, ''); // (actions)
                text = text.replace(/\[[^\]]*\]/g, ''); // [actions]
                
                // Remove URLs - replace with "link"
                text = text.replace(/https?:\/\/[^\s]+/g, 'link');
                
                // Remove emojis and special characters
                text = text.replace(/[\u{1F600}-\u{1F64F}]/gu, ''); // Emoticons
                text = text.replace(/[\u{1F300}-\u{1F5FF}]/gu, ''); // Misc Symbols and Pictographs
                text = text.replace(/[\u{1F680}-\u{1F6FF}]/gu, ''); // Transport and Map
                text = text.replace(/[\u{1F1E0}-\u{1F1FF}]/gu, ''); // Flags
                text = text.replace(/[\u{2600}-\u{26FF}]/gu, ''); // Misc symbols
                text = text.replace(/[\u{2700}-\u{27BF}]/gu, ''); // Dingbats
                
                // Clean up multiple spaces
                text = text.replace(/\s+/g, ' ').trim();
                
                // Remove empty brackets/parentheses
                text = text.replace(/\[\]/g, '');
                text = text.replace(/\(\)/g, '');
                
                return text;
            },
            
            generateAudio: async function() {
                const errorMsg = document.getElementById('audioErrorMsg');
                const progressBar = document.getElementById('audioProgressBar');
                const progressFill = progressBar.querySelector('.progress-fill');
                const infoText = document.getElementById('audioGenerationInfo');
                const downloadBtn = document.getElementById('downloadAudioBtn');
                
                errorMsg.style.display = 'none';
                progressBar.style.display = 'block';
                downloadBtn.style.display = 'none';
                
                if (!this.elevenLabsApiKey) {
                    errorMsg.textContent = 'Please configure your ElevenLabs API key';
                    errorMsg.style.display = 'block';
                    progressBar.style.display = 'none';
                    return;
                }
                
                const messages = this.getMessages();
                if (messages.length === 0) {
                    errorMsg.textContent = 'No messages to generate audio for';
                    errorMsg.style.display = 'block';
                    progressBar.style.display = 'none';
                    return;
                }
                
                // Get character voice mappings
                const characters = storage.getCharacters();
                const char1 = storage.getCharacterById(document.getElementById('char1Selector').value);
                const char2 = storage.getCharacterById(document.getElementById('char2Selector').value);
                
                // Get selected voices from the dropdowns
                const char1Voice = document.getElementById('char1Voice').value;
                const char2Voice = document.getElementById('char2Voice').value;
                
                const voiceMapping = {};
                if (char1) voiceMapping[char1.name.toLowerCase()] = char1Voice;
                if (char2) voiceMapping[char2.name.toLowerCase()] = char2Voice;
                
                // Default voices for unmapped characters
                const defaultVoices = {
                    female: '21m00Tcm4TlvDq8ikWAM', // Rachel
                    male: '29vD33N1CtxCmqQRPOHJ'     // Drew
                };
                
                const audioSegments = [];
                let processedCount = 0;
                
                for (const message of messages) {
                    infoText.textContent = `Generating audio for ${message.username}: ${message.content.substring(0, 30)}...`;
                    
                    // Preprocess text for speech
                    const processedText = this.preprocessTextForSpeech(message.content);
                    
                    // Skip empty messages after preprocessing
                    if (!processedText.trim()) {
                        processedCount++;
                        progressFill.style.width = (processedCount / messages.length * 100) + '%';
                        continue;
                    }
                    
                    // Get voice ID for this user
                    let voiceId = voiceMapping[message.username.toLowerCase()];
                    if (!voiceId) {
                        // Assign default voice based on simple heuristic
                        voiceId = defaultVoices.female; // You could make this smarter
                    }
                    
                    try {
                        const response = await fetch(`https://api.elevenlabs.io/v1/text-to-speech/${voiceId}`, {
                            method: 'POST',
                            headers: {
                                'Accept': 'audio/mpeg',
                                'Content-Type': 'application/json',
                                'xi-api-key': this.elevenLabsApiKey
                            },
                            body: JSON.stringify({
                                text: processedText,
                                model_id: 'eleven_turbo_v2_5',
                                voice_settings: {
                                    stability: 0.4,
                                    similarity_boost: 0.8,
                                    style: 0.2,
                                    use_speaker_boost: true
                                }
                            })
                        });
                        
                        if (!response.ok) {
                            throw new Error(`API request failed: ${response.status}`);
                        }
                        
                        const audioData = await response.arrayBuffer();
                        audioSegments.push(audioData);
                        
                    } catch (error) {
                        console.error('Error generating audio for message:', error);
                        // Continue with other messages even if one fails
                    }
                    
                    processedCount++;
                    progressFill.style.width = (processedCount / messages.length * 100) + '%';
                }
                
                if (audioSegments.length === 0) {
                    errorMsg.textContent = 'Failed to generate audio for any messages';
                    errorMsg.style.display = 'block';
                    progressBar.style.display = 'none';
                    return;
                }
                
                // Combine audio segments
                infoText.textContent = 'Combining audio segments...';
                const combinedAudio = await this.combineAudioSegments(audioSegments);
                
                // Display audio player
                const audioPlayer = document.getElementById('generatedAudio');
                const audioContainer = document.getElementById('audioPlayerContainer');
                
                const blob = new Blob([combinedAudio], { type: 'audio/mpeg' });
                const audioUrl = URL.createObjectURL(blob);
                
                audioPlayer.src = audioUrl;
                audioContainer.style.display = 'block';
                downloadBtn.style.display = 'inline-block';
                
                // Setup download button
                downloadBtn.onclick = () => {
                    const a = document.createElement('a');
                    a.href = audioUrl;
                    a.download = 'conversation_audio.mp3';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                };
                
                progressBar.style.display = 'none';
                infoText.textContent = 'Audio generation complete!';
            },
            
            combineAudioSegments: async function(segments) {
                // Simple concatenation for now
                // In a more sophisticated implementation, you'd use Web Audio API
                // to add proper gaps between segments
                const totalLength = segments.reduce((sum, seg) => sum + seg.byteLength, 0);
                const combined = new Uint8Array(totalLength);
                
                let offset = 0;
                for (const segment of segments) {
                    combined.set(new Uint8Array(segment), offset);
                    offset += segment.byteLength;
                }
                
                return combined;
            }
        };
        
        // Add getCharacterById method to storage if it doesn't exist
        if (!storage.getCharacterById) {
            storage.getCharacterById = function(id) {
                const characters = this.getCharacters();
                return characters.find(c => c.id === id);
            };
        }
        
        // Initialize voice generation when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                voiceGeneration.init();
            });
        } else {
            voiceGeneration.init();
        }
    </script>
</body>
</html>
